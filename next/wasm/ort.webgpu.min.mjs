/*! For license information please see ort.webgpu.min.mjs.LICENSE.txt */
let e;var r=Object.defineProperty,n=Object.getOwnPropertyDescriptor,o=Object.getOwnPropertyNames,a=Object.prototype.hasOwnProperty,s,i,u,l,p,f,d,c,h,y,m,g,w,b,v,T,E,I,C,A,x,O,U,L,$,R,M,N,B,S,k,P,_,G=(e=function(e){if("u">typeof require)return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')},"u">typeof require?require:"u">typeof Proxy?new Proxy(e,{get:(e,r)=>("u">typeof require?require:e)[r]}):e),D=(e,r)=>()=>(e&&(r=e(e=0)),r),W=(e,n)=>{for(var o in n)r(e,o,{get:n[o],enumerable:!0})},F=e=>((e,s,i,u)=>{if(s&&"object"==typeof s||"function"==typeof s)for(let l of o(s))a.call(e,l)||l===i||r(e,l,{get:()=>s[l],enumerable:!(u=n(s,l))||u.enumerable});return e})(r({},"__esModule",{value:!0}),e),j=D(()=>{"use strict";s=new Map,i=[],u=(e,r,n)=>{if(r&&"function"==typeof r.init&&"function"==typeof r.createInferenceSessionHandler){let o=s.get(e);if(void 0===o)s.set(e,{backend:r,priority:n});else{if(o.priority>n)return;if(o.priority===n&&o.backend!==r)throw Error(`cannot register backend "${e}" using priority ${n}`)}if(n>=0){let r=i.indexOf(e);-1!==r&&i.splice(r,1);for(let r=0;r<i.length;r++)if(s.get(i[r]).priority<=n)return void i.splice(r,0,e);i.push(e)}return}throw TypeError("not a valid backend")},l=async e=>{let r=s.get(e);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let n=!!r.initPromise;try{return n||(r.initPromise=r.backend.init(e)),await r.initPromise,r.initialized=!0,r.backend}catch(e){return n||(r.error=`${e}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},p=async e=>{let r=e.executionProviders||[],n=r.map(e=>"string"==typeof e?e:e.name),o=0===n.length?i:n,a,s=[],u=new Set;for(let e of o){let r=await l(e);"string"==typeof r?s.push({name:e,err:r}):(a||(a=r),a===r&&u.add(e))}if(!a)throw Error(`no available backend found. ERR: ${s.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:r}of s)n.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${r}`);let p=r.filter(e=>u.has("string"==typeof e?e:e.name));return[a,new Proxy(e,{get:(e,r)=>"executionProviders"===r?p:Reflect.get(e,r)})]}}),V=D(()=>{"use strict";j()}),z=D(()=>{"use strict";f="1.23.2"}),H=D(()=>{"use strict";z(),d="warning",Object.defineProperty(c={wasm:{},webgl:{},webgpu:{},versions:{common:f},set logLevel(t){if(void 0!==t){if("string"!=typeof t||-1===["verbose","info","warning","error","fatal"].indexOf(t))throw Error(`Unsupported logging level: ${t}`);d=t}},get logLevel(){return d}},"logLevel",{enumerable:!0})}),q=D(()=>{"use strict";H(),h=c}),Z=D(()=>{"use strict";y=(e,r)=>{let n="u">typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=e.dims[3],n.height=e.dims[2];let o=n.getContext("2d");if(null!=o){let a,s;r?.tensorLayout!==void 0&&"NHWC"===r.tensorLayout?(a=e.dims[2],s=e.dims[3]):(a=e.dims[3],s=e.dims[2]);let i=r?.format!==void 0?r.format:"RGB",u=r?.norm,l,p;void 0===u||void 0===u.mean?l=[255,255,255,255]:"number"==typeof u.mean?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(l[3]=u.mean[3])),void 0===u||void 0===u.bias?p=[0,0,0,0]:"number"==typeof u.bias?p=[u.bias,u.bias,u.bias,u.bias]:(p=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(p[3]=u.bias[3]));let f=s*a,d=0,c=f,h=2*f,y=-1;"RGBA"===i?(d=0,c=f,h=2*f,y=3*f):"RGB"===i?(d=0,c=f,h=2*f):"RBG"===i&&(d=0,h=f,c=2*f);for(let r=0;r<s;r++)for(let n=0;n<a;n++)o.fillStyle="rgba("+(e.data[d++]-p[0])*l[0]+","+(e.data[c++]-p[1])*l[1]+","+(e.data[h++]-p[2])*l[2]+","+(-1===y?255:(e.data[y++]-p[3])*l[3])+")",o.fillRect(n,r,1,1);if("toDataURL"in n)return n.toDataURL();throw Error("toDataURL is not supported")}throw Error("Can not access image data")},m=(e,r)=>{let n="u">typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),o;if(null!=n){let a,s,i;r?.tensorLayout!==void 0&&"NHWC"===r.tensorLayout?(a=e.dims[2],s=e.dims[1],i=e.dims[3]):(a=e.dims[3],s=e.dims[2],i=e.dims[1]);let u=void 0!==r&&void 0!==r.format?r.format:"RGB",l=r?.norm,p,f;void 0===l||void 0===l.mean?p=[255,255,255,255]:"number"==typeof l.mean?p=[l.mean,l.mean,l.mean,l.mean]:(p=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(p[3]=l.mean[3])),void 0===l||void 0===l.bias?f=[0,0,0,0]:"number"==typeof l.bias?f=[l.bias,l.bias,l.bias,l.bias]:(f=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(f[3]=l.bias[3]));let d=s*a;if(void 0!==r&&(void 0!==r.format&&4===i&&"RGBA"!==r.format||3===i&&"RGB"!==r.format&&"BGR"!==r.format))throw Error("Tensor format doesn't match input tensor dims");let c=0,h=1,y=2,m=3,g=0,w=d,b=2*d,v=-1;"RGBA"===u?(g=0,w=d,b=2*d,v=3*d):"RGB"===u?(g=0,w=d,b=2*d):"RBG"===u&&(g=0,b=d,w=2*d),o=n.createImageData(a,s);for(let r=0;r<s*a;c+=4,h+=4,y+=4,m+=4,r++)o.data[c]=(e.data[g++]-f[0])*p[0],o.data[h]=(e.data[w++]-f[1])*p[1],o.data[y]=(e.data[b++]-f[2])*p[2],o.data[m]=-1===v?255:(e.data[v++]-f[3])*p[3]}else throw Error("Can not access image data");return o}}),X=D(()=>{"use strict";K(),g=(e,r)=>{if(void 0===e)throw Error("Image buffer must be defined");if(void 0===r.height||void 0===r.width)throw Error("Image height and width must be defined");if("NHWC"===r.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:n,width:o}=r,a=r.norm??{mean:255,bias:0},s,i;s="number"==typeof a.mean?[a.mean,a.mean,a.mean,a.mean]:[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],i="number"==typeof a.bias?[a.bias,a.bias,a.bias,a.bias]:[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let u=void 0!==r.format?r.format:"RGBA",l=void 0!==r.tensorFormat&&void 0!==r.tensorFormat?r.tensorFormat:"RGB",p=n*o,f=new Float32Array("RGBA"===l?4*p:3*p),d=4,c=0,h=1,y=2,m=3,g=0,w=p,b=2*p,v=-1;"RGB"===u&&(d=3,c=0,h=1,y=2,m=-1),"RGBA"===l?v=3*p:"RBG"===l?(g=0,b=p,w=2*p):"BGR"===l&&(b=0,w=p,g=2*p);for(let r=0;r<p;r++,c+=d,y+=d,h+=d,m+=d)f[g++]=(e[c]+i[0])/s[0],f[w++]=(e[h]+i[1])/s[1],f[b++]=(e[y]+i[2])/s[2],-1!==v&&-1!==m&&(f[v++]=(e[m]+i[3])/s[3]);return"RGBA"===l?new L("float32",f,[1,4,n,o]):new L("float32",f,[1,3,n,o])},w=async(e,r)=>{let n="u">typeof HTMLImageElement&&e instanceof HTMLImageElement,o="u">typeof ImageData&&e instanceof ImageData,a="u">typeof ImageBitmap&&e instanceof ImageBitmap,s="string"==typeof e,i,u=r??{},l=()=>{if("u">typeof document)return document.createElement("canvas");if("u">typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},p=e=>"u">typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){let n=l();n.width=e.width,n.height=e.height;let o=p(n);if(null!=o){let n=e.height,a=e.width;if(void 0!==r&&void 0!==r.resizedHeight&&void 0!==r.resizedWidth&&(n=r.resizedHeight,a=r.resizedWidth),void 0!==r){if(u=r,void 0!==r.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");u.tensorFormat="RGBA",u.height=n,u.width=a}else u.tensorFormat="RGBA",u.height=n,u.width=a;o.drawImage(e,0,0),i=o.getImageData(0,0,a,n).data}else throw Error("Can not access image data")}else if(o){let n,o;if(void 0!==r&&void 0!==r.resizedWidth&&void 0!==r.resizedHeight?(n=r.resizedHeight,o=r.resizedWidth):(n=e.height,o=e.width),void 0!==r&&(u=r),u.format="RGBA",u.height=n,u.width=o,void 0!==r){let r=l();r.width=o,r.height=n;let a=p(r);if(null!=a)a.putImageData(e,0,0),i=a.getImageData(0,0,o,n).data;else throw Error("Can not access image data")}else i=e.data}else if(a){if(void 0===r)throw Error("Please provide image config with format for Imagebitmap");let n=l();n.width=e.width,n.height=e.height;let o=p(n);if(null!=o){let r=e.height,n=e.width;return o.drawImage(e,0,0,n,r),i=o.getImageData(0,0,n,r).data,u.height=r,u.width=n,g(i,u)}throw Error("Can not access image data")}else{if(s)return new Promise((r,n)=>{let o=l(),a=p(o);if(!e||!a)return n();let s=new Image;s.crossOrigin="Anonymous",s.src=e,s.onload=()=>{o.width=s.width,o.height=s.height,a.drawImage(s,0,0,o.width,o.height);let e=a.getImageData(0,0,o.width,o.height);u.height=o.height,u.width=o.width,r(g(e.data,u))}});throw Error("Input data provided is not supported - aborted tensor creation")}if(void 0!==i)return g(i,u);throw Error("Input data provided is not supported - aborted tensor creation")},b=(e,r)=>{let{width:n,height:o,download:a,dispose:s}=r;return new L({location:"texture",type:"float32",texture:e,dims:[1,o,n,4],download:a,dispose:s})},v=(e,r)=>{let{dataType:n,dims:o,download:a,dispose:s}=r;return new L({location:"gpu-buffer",type:n??"float32",gpuBuffer:e,dims:o,download:a,dispose:s})},T=(e,r)=>{let{dataType:n,dims:o,download:a,dispose:s}=r;return new L({location:"ml-tensor",type:n??"float32",mlTensor:e,dims:o,download:a,dispose:s})},E=(e,r,n)=>new L({location:"cpu-pinned",type:e,data:r,dims:n??[r.length]})}),Y=D(()=>{"use strict";I=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),C=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),A=!1,x=()=>{if(!A){A=!0;let e="u">typeof BigInt64Array&&BigInt64Array.from,r="u">typeof BigUint64Array&&BigUint64Array.from,n=globalThis.Float16Array,o="u">typeof n&&n.from;e&&(I.set("int64",BigInt64Array),C.set(BigInt64Array,"int64")),r&&(I.set("uint64",BigUint64Array),C.set(BigUint64Array,"uint64")),o?(I.set("float16",n),C.set(n,"float16")):I.set("float16",Uint16Array)}}}),J=D(()=>{"use strict";K(),O=e=>{let r=1;for(let n=0;n<e.length;n++){let o=e[n];if("number"!=typeof o||!Number.isSafeInteger(o))throw TypeError(`dims[${n}] must be an integer, got: ${o}`);if(o<0)throw RangeError(`dims[${n}] must be a non-negative integer, got: ${o}`);r*=o}return r},U=(e,r)=>{switch(e.location){case"cpu":return new L(e.type,e.data,r);case"cpu-pinned":return new L({location:"cpu-pinned",data:e.data,type:e.type,dims:r});case"texture":return new L({location:"texture",texture:e.texture,type:e.type,dims:r});case"gpu-buffer":return new L({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:r});case"ml-tensor":return new L({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:r});default:throw Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),K=D(()=>{"use strict";Z(),X(),Y(),J(),L=class{constructor(e,r,n){let o,a;if(x(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,o=e.type,a=e.dims,e.location){case"cpu-pinned":{let r=I.get(o);if(!r)throw TypeError(`unsupported type "${o}" to create tensor from pinned buffer`);if(!(e.data instanceof r))throw TypeError(`buffer should be of type ${r.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==o)throw TypeError(`unsupported type "${o}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==o&&"float16"!==o&&"int32"!==o&&"int64"!==o&&"uint32"!==o&&"uint8"!==o&&"bool"!==o&&"uint4"!==o&&"int4"!==o)throw TypeError(`unsupported type "${o}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==o&&"float16"!==o&&"int32"!==o&&"int64"!==o&&"uint32"!==o&&"uint64"!==o&&"int8"!==o&&"uint8"!==o&&"bool"!==o&&"uint4"!==o&&"int4"!==o)throw TypeError(`unsupported type "${o}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let s,i;if("string"==typeof e)if(o=e,i=n,"string"===e){if(!Array.isArray(r))throw TypeError("A string tensor's data must be a string array.");s=r}else{let n=I.get(e);if(void 0===n)throw TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(r)){if("float16"===e&&n===Uint16Array||"uint4"===e||"int4"===e)throw TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${n.name} as data.`);s="uint64"===e||"int64"===e?n.from(r,BigInt):n.from(r)}else if(r instanceof n)s=r;else if(r instanceof Uint8ClampedArray)if("uint8"===e)s=Uint8Array.from(r);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if("float16"===e&&r instanceof Uint16Array&&n!==Uint16Array)s=new globalThis.Float16Array(r.buffer,r.byteOffset,r.length);else throw TypeError(`A ${o} tensor's data must be type of ${n}`)}else if(i=r,Array.isArray(e)){if(0===e.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let r=typeof e[0];if("string"===r)o="string",s=e;else if("boolean"===r)o="bool",s=Uint8Array.from(e);else throw TypeError(`Invalid element type of data array: ${r}.`)}else if(e instanceof Uint8ClampedArray)o="uint8",s=Uint8Array.from(e);else{let r=C.get(e.constructor);if(void 0===r)throw TypeError(`Unsupported type for tensor data: ${e.constructor}.`);o=r,s=e}if(void 0===i)i=[s.length];else if(!Array.isArray(i))throw TypeError("A tensor's dims must be a number array");a=i,this.cpuData=s,this.dataLocation="cpu"}let s=O(a);if(this.cpuData&&s!==this.cpuData.length&&("uint4"!==o&&"int4"!==o||Math.ceil(s/2)!==this.cpuData.length))throw Error(`Tensor's size(${s}) does not match data length(${this.cpuData.length}).`);this.type=o,this.dims=a,this.size=s}static async fromImage(e,r){return w(e,r)}static fromTexture(e,r){return b(e,r)}static fromGpuBuffer(e,r){return v(e,r)}static fromMLTensor(e,r){return T(e,r)}static fromPinnedBuffer(e,r,n){return E(e,r,n)}toDataURL(e){return y(this,e)}toImageData(e){return m(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,e&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");return U(this,e)}}}),Q=D(()=>{"use strict";K(),$=L}),ee=D(()=>{"use strict";H(),R=(e,r)=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&console.timeStamp(`${e}::ORT::${r}`)},M=(e,r)=>{let n=Error().stack?.split(/\r\n|\r|\n/g)||[],o=!1;for(let a=0;a<n.length;a++){if(o&&!n[a].includes("TRACE_FUNC")){let o=`FUNC_${e}::${n[a].trim().split(" ")[1]}`;r&&(o+=`::${r}`),R("CPU",o);return}n[a].includes("TRACE_FUNC")&&(o=!0)}},N=e=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&M("BEGIN",e)},B=e=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&M("END",e)},S=e=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&console.time(`ORT::${e}`)},k=e=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&console.timeEnd(`ORT::${e}`)}}),et=D(()=>{"use strict";j(),Q(),ee(),P=class e{constructor(e){this.handler=e}async run(e,r,n){N(),S("InferenceSession.run");let o={},a={};if("object"!=typeof e||null===e||e instanceof $||Array.isArray(e))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if("object"==typeof r){if(null===r)throw TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof $)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(0===r.length)throw TypeError("'fetches' cannot be an empty array.");for(let e of(s=!1,r)){if("string"!=typeof e)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw RangeError(`'fetches' contains invalid output name: ${e}.`);o[e]=null}if("object"==typeof n&&null!==n)a=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else{let e=!1,i=Object.getOwnPropertyNames(r);for(let n of this.outputNames)if(-1!==i.indexOf(n)){let a=r[n];(null===a||a instanceof $)&&(e=!0,s=!1,o[n]=a)}if(e){if("object"==typeof n&&null!==n)a=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else a=r}}else if("u">typeof r)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let r of this.inputNames)if(typeof e[r]>"u")throw Error(`input '${r}' is missing in 'feeds'.`);if(s)for(let e of this.outputNames)o[e]=null;let i=await this.handler.run(e,o,a),u={};for(let e in i)if(Object.hasOwnProperty.call(i,e)){let r=i[e];r instanceof $?u[e]=r:u[e]=new $(r.type,r.data,r.dims)}return k("InferenceSession.run"),B(),u}async release(){return this.handler.dispose()}static async create(r,n,o,a){N(),S("InferenceSession.create");let s,i={};if("string"==typeof r){if(s=r,"object"==typeof n&&null!==n)i=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(s=r,"object"==typeof n&&null!==n)i=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||"u">typeof SharedArrayBuffer&&r instanceof SharedArrayBuffer){let e=0,u=r.byteLength;if("object"==typeof n&&null!==n)i=n;else if("number"==typeof n){if(!Number.isSafeInteger(e=n))throw RangeError("'byteOffset' must be an integer.");if(e<0||e>=r.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(u=r.byteLength-e,"number"==typeof o){if(!Number.isSafeInteger(u=o))throw RangeError("'byteLength' must be an integer.");if(u<=0||e+u>r.byteLength)throw RangeError(`'byteLength' is out of range (0, ${r.byteLength-e}].`);if("object"==typeof a&&null!==a)i=a;else if("u">typeof a)throw TypeError("'options' must be an object.")}else if("u">typeof o)throw TypeError("'byteLength' must be a number.")}else if("u">typeof n)throw TypeError("'options' must be an object.");s=new Uint8Array(r,e,u)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[u,l]=await p(i),f=await u.createInferenceSessionHandler(s,l);return k("InferenceSession.create"),B(),new e(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),er=D(()=>{"use strict";et(),_=P}),en=D(()=>{}),eo=D(()=>{}),ea=D(()=>{}),es=D(()=>{}),ei={};W(ei,{InferenceSession:()=>_,TRACE:()=>R,TRACE_EVENT_BEGIN:()=>S,TRACE_EVENT_END:()=>k,TRACE_FUNC_BEGIN:()=>N,TRACE_FUNC_END:()=>B,Tensor:()=>$,env:()=>h,registerBackend:()=>u});var eu=D(()=>{"use strict";V(),q(),er(),Q(),en(),eo(),ee(),ea(),es()}),el=D(()=>{}),ep={};W(ep,{default:()=>ed});var ef,ed,ec,eh,ey,em,eg,ew,eb,ev,eT,eE,eI,eC,eA,ex,eO,eU,eL,e$,eR,eM,eN,eB,eS,ek,eP,e_,eG,eD,eW,eF,ej,eV,ez,eH,eq,eZ,eX,eY,eJ,eK,eQ,e0,e1,e2,e3,e4,e6,e8,e5,e9,e7,te=D(()=>{"use strict";tq(),tr(),tt(),(ef=globalThis.self?.name==="ort-wasm-proxy-worker")&&(self.onmessage=e=>{let{type:r,in:n}=e.data;try{switch(r){case"init-wasm":eU(n.wasm).then(()=>{th(n).then(()=>{postMessage({type:r})},e=>{postMessage({type:r,err:e})})},e=>{postMessage({type:r,err:e})});break;case"init-ep":{let{epName:e,env:o}=n;ty(o,e).then(()=>{postMessage({type:r})},e=>{postMessage({type:r,err:e})});break}case"copy-from":{let{buffer:e}=n,o=tw(e);postMessage({type:r,out:o});break}case"create":{let{model:e,options:o}=n;tb(e,o).then(e=>{postMessage({type:r,out:e})},e=>{postMessage({type:r,err:e})});break}case"release":tv(n),postMessage({type:r});break;case"run":{let{sessionId:e,inputIndices:o,inputs:a,outputIndices:s,options:i}=n;tE(e,o,a,s,Array(s.length).fill(null),i).then(e=>{e.some(e=>"cpu"!==e[3])?postMessage({type:r,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:r,out:e},tC([...a,...e]))},e=>{postMessage({type:r,err:e})});break}case"end-profiling":tI(n),postMessage({type:r})}}catch(e){postMessage({type:r,err:e})}}),ed=ef?null:e=>new Worker(e??ey,{type:"module",name:"ort-wasm-proxy-worker"})}),tt=D(()=>{"use strict";el(),ec=typeof location>"u"?void 0:location.origin,eh=import.meta.url>"file:"&&import.meta.url<"file;",ey=(()=>{if(eh){let e=URL;return new URL(new e("ort.webgpu.min.mjs",import.meta.url).href,ec).href}return import.meta.url})(),em=()=>{if(ey&&!ey.startsWith("blob:"))return ey.substring(0,ey.lastIndexOf("/")+1)},eg=(e,r)=>{try{let n=r??ey;return(n?new URL(e,n):new URL(e)).origin===ec}catch{return!1}},ew=async e=>{let r=await (await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},eb=async e=>(await import(e)).default,ev=(te(),F(ep)).default,eT=async()=>{if(!ey)throw Error("Failed to load proxy worker: cannot determine the script source URL.");if(eg(ey))return[void 0,ev()];let e=await ew(ey);return[e,ev(e)]},eE=void 0,eI=async(e,r,n,o)=>{let a=eE&&!(e||r);if(a)if(ey)a=eg(ey);else if(o&&!n)a=!0;else throw Error("cannot determine the script source URL.");if(a)return[void 0,eE];{let o,a,s="ort-wasm-simd-threaded.asyncify.mjs",i=e??((e,r)=>{let n=r??ey;try{return(n?new URL(e,n):new URL(e)).href}catch{return}})(s,r),u=n&&i&&!eg(i,r),l=u?await ew(i):i??(o=s,a=r,`${a??"./"}${o}`);return[u?l:void 0,await eb(l)]}}}),tr=D(()=>{"use strict";tt(),eA=!1,ex=!1,eO=!1,eU=async e=>{if(eA)return Promise.resolve();if(ex)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(eO)throw Error("previous call to 'initializeWebAssembly()' failed.");ex=!0;let r=e.initTimeout,n=e.numThreads;if(!1!==e.simd){if("relaxed"===e.simd){if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}})())throw Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})())throw Error("WebAssembly SIMD is not supported in the current environment.")}let o=(()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return"u">typeof MessageChannel&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}})();n>1&&!o&&("u">typeof self&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=n=1);let a=e.wasmPaths,s="string"==typeof a?a:void 0,i=a?.mjs,u=i?.href??i,l=a?.wasm,p=l?.href??l,f=e.wasmBinary,[d,c]=await eI(u,s,n>1,!!f||!!p),h=!1,y=[];if(r>0&&y.push(new Promise(e=>{setTimeout(()=>{h=!0,e()},r)})),y.push(new Promise((e,r)=>{let o={numThreads:n};if(f)o.wasmBinary=f;else if(p||s)o.locateFile=e=>p??s+e;else if(u&&0!==u.indexOf("blob:"))o.locateFile=e=>new URL(e,u).href;else if(d){let e=em();e&&(o.locateFile=r=>e+r)}c(o).then(r=>{ex=!1,eA=!0,eC=r,e(),d&&URL.revokeObjectURL(d)},e=>{ex=!1,eO=!0,r(e)})})),await Promise.race(y),h)throw Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},eL=()=>{if(eA&&eC)return eC;throw Error("WebAssembly is not initialized yet.")}}),tn=D(()=>{"use strict";tr(),e$=(e,r)=>{let n=eL(),o=n.lengthBytesUTF8(e)+1,a=n._malloc(o);return n.stringToUTF8(e,a,o),r.push(a),a},eR=(e,r,n,o)=>{if("object"==typeof e&&null!==e){if(n.has(e))throw Error("Circular reference in options");n.add(e)}Object.entries(e).forEach(([e,a])=>{let s=r?r+e:e;if("object"==typeof a)eR(a,s+".",n,o);else if("string"==typeof a||"number"==typeof a)o(s,a.toString());else if("boolean"==typeof a)o(s,a?"1":"0");else throw Error(`Can't handle extra config type: ${typeof a}`)})},eM=e=>{let r=eL(),n=r.stackSave();try{let n=r.PTR_SIZE,o=r.stackAlloc(2*n);r._OrtGetLastError(o,o+n);let a=Number(r.getValue(o,4===n?"i32":"i64")),s=r.getValue(o+n,"*"),i=s?r.UTF8ToString(s):"";throw Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${i}`)}finally{r.stackRestore(n)}}}),to=D(()=>{"use strict";tr(),tn(),eN=e=>{let r=eL(),n=0,o=[],a=e||{};try{if(e?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw Error(`log severity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(a.terminate=!1);let s=0;return e?.tag!==void 0&&(s=e$(e.tag,o)),n=r._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,s),0===n&&eM("Can't create run options."),e?.extra!==void 0&&eR(e.extra,"",new WeakSet,(e,a)=>{let s=e$(e,o),i=e$(a,o);0!==r._OrtAddRunConfigEntry(n,s,i)&&eM(`Can't set a run config entry: ${e} - ${a}.`)}),[n,o]}catch(e){throw 0!==n&&r._OrtReleaseRunOptions(n),o.forEach(e=>r._free(e)),e}}}),ta=D(()=>{"use strict";tr(),tn(),eB=(e,r,n,o)=>{let a=e$(r,o),s=e$(n,o);0!==eL()._OrtAddSessionConfigEntry(e,a,s)&&eM(`Can't set a session config entry: ${r} - ${n}.`)},eS=(e,r,n,o)=>{let a=e$(r,o),s=e$(n,o);e.push([a,s])},ek=async(e,r,n)=>{for(let o of r){let r="string"==typeof o?o:o.name,a=[];switch(r){case"webnn":if(r="WEBNN","string"!=typeof o){let r=o?.deviceType;r&&eB(e,"deviceType",r,n)}break;case"webgpu":{let e;if(r="WebGPU","string"!=typeof o&&o.device)if("u">typeof GPUDevice&&o.device instanceof GPUDevice)e=o.device;else throw Error("Invalid GPU device set in WebGPU EP options.");let s=eL().webgpuRegisterDevice(e);if(s){let[e,r,o]=s;eS(a,"deviceId",e.toString(),n),eS(a,"webgpuInstance",r.toString(),n),eS(a,"webgpuDevice",o.toString(),n)}}break;case"wasm":case"cpu":continue;default:throw Error(`not supported execution provider: ${r}`)}let s=e$(r,n),i=a.length,u=0,l=0;if(i>0){u=eL()._malloc(i*eL().PTR_SIZE),n.push(u),l=eL()._malloc(i*eL().PTR_SIZE),n.push(l);for(let e=0;e<i;e++)eL().setValue(u+e*eL().PTR_SIZE,a[e][0],"*"),eL().setValue(l+e*eL().PTR_SIZE,a[e][1],"*")}await eL()._OrtAppendExecutionProvider(e,s,u,l,i)!==0&&eM(`Can't append execution provider: ${r}.`)}},eP=async e=>{var r;let n,o=eL(),a=0,s=[],i=e||{};(r=i).extra||(r.extra={}),r.extra.session||(r.extra.session={}),(n=r.extra.session).use_ort_model_bytes_directly||(n.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(e=>("string"==typeof e?e:e.name)==="webgpu")&&(r.enableMemPattern=!1);try{let e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${e}`)}})(i.graphOptimizationLevel??"all"),r=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${e}`)}})(i.executionMode??"sequential"),n="string"==typeof i.logId?e$(i.logId,s):0,u=i.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw Error(`log severity level is not valid: ${u}`);let l=i.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw Error(`log verbosity level is not valid: ${l}`);let p="string"==typeof i.optimizedModelFilePath?e$(i.optimizedModelFilePath,s):0;if(a=o._OrtCreateSessionOptions(e,!!i.enableCpuMemArena,!!i.enableMemPattern,r,!!i.enableProfiling,0,n,u,l,p),0===a&&eM("Can't create session options."),i.executionProviders&&await ek(a,i.executionProviders,s),void 0!==i.enableGraphCapture){if("boolean"!=typeof i.enableGraphCapture)throw Error(`enableGraphCapture must be a boolean value: ${i.enableGraphCapture}`);eB(a,"enableGraphCapture",i.enableGraphCapture.toString(),s)}if(i.freeDimensionOverrides)for(let[e,r]of Object.entries(i.freeDimensionOverrides)){if("string"!=typeof e)throw Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof r||!Number.isInteger(r)||r<0)throw Error(`free dimension override value must be a non-negative integer: ${r}`);let n=e$(e,s);0!==o._OrtAddFreeDimensionOverride(a,n,r)&&eM(`Can't set a free dimension override: ${e} - ${r}.`)}return void 0!==i.extra&&eR(i.extra,"",new WeakSet,(e,r)=>{eB(a,e,r,s)}),[a,s]}catch(e){throw 0!==a&&0!==o._OrtReleaseSessionOptions(a)&&eM("Can't release session options."),s.forEach(e=>o._free(e)),e}}}),ts=D(()=>{"use strict";e_=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw Error(`unsupported data type: ${e}`)}},eG=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw Error(`unsupported data type: ${e}`)}},eD=(e,r)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],o="number"==typeof r?r:r.reduce((e,r)=>e*r,1);return n>0?Math.ceil(o*n):void 0},eW=e=>{switch(e){case"float16":return"u">typeof Float16Array&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${e}`)}},eF=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${e}`)}},ej=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,eV=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,ez=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw Error(`unsupported data location: ${e}`)}}}),ti=D(()=>{"use strict";el(),eH=async e=>{if("string"!=typeof e)return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e);{let r=await fetch(e);if(!r.ok)throw Error(`failed to load external data file: ${e}`);let n=r.headers.get("Content-Length"),o=n?parseInt(n,10):0;if(o<0x40000000)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw Error(`failed to load external data file: ${e}, no response body.`);let n=r.body.getReader(),a;try{a=new ArrayBuffer(o)}catch(e){if(e instanceof RangeError){let e=Math.ceil(o/65536);a=new WebAssembly.Memory({initial:e,maximum:e}).buffer}else throw e}let s=0;for(;;){let{done:e,value:r}=await n.read();if(e)break;let o=r.byteLength;new Uint8Array(a,s,o).set(r),s+=o}return new Uint8Array(a,0,o)}}}}),tu=D(()=>{"use strict";ts(),eq=(e,r)=>new(eW(r))(e)}),tl=D(()=>{"use strict";ts(),eZ=["V","I","W","E","F"],eJ=(e,r)=>{eX=e,eY=r},eK=(...e)=>{eY&&((e,r)=>{var n,o;let a=eF(e);a>=eF(eX)&&(n=a,o="function"==typeof r?r():r,console.log(`[${eZ[n]},${new Date().toISOString()}]${o}`))})(...e)}}),tp=D(()=>{"use strict";ts(),tl(),eQ=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),e0=(e,r)=>{if("int32"===r)return e;let n=eQ.get(r);if(!n)throw Error(`WebNN backend does not support data type: ${r}`);let o=n/8;if(e.byteLength%o!=0)throw Error(`Invalid Uint8Array length - must be a multiple of ${o}.`);let a=e.byteLength/o,s=new(eW(r))(e.buffer,e.byteOffset,a);switch(r){case"int64":case"uint64":{let e=new Int32Array(a);for(let r=0;r<a;r++){let n=s[r];if(n>2147483647n||n<-2147483648n)throw Error("Can not convert int64 data to int32 - value out of range.");e[r]=Number(n)}return new Uint8Array(e.buffer)}case"int8":case"uint8":case"uint32":if("uint32"===r&&s.some(e=>e>0x7fffffff))throw Error("Can not convert uint32 data to int32 - value out of range.");return new Uint8Array(Int32Array.from(s,Number).buffer);default:throw Error(`Unsupported data conversion from ${r} to 'int32'`)}},e1=(e,r)=>{if("int32"===r)return e;if(e.byteLength%4!=0)throw Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let n=e.byteLength/4,o=new Int32Array(e.buffer,e.byteOffset,n);switch(r){case"int64":return new Uint8Array(BigInt64Array.from(o,BigInt).buffer);case"uint64":if(o.some(e=>e<0))throw Error("Can not convert int32 data to uin64 - negative value found.");return new Uint8Array(BigUint64Array.from(o,BigInt).buffer);case"int8":if(o.some(e=>e<-128||e>127))throw Error("Can not convert int32 data to int8 - value out of range.");return new Uint8Array(Int8Array.from(o,Number).buffer);case"uint8":if(o.some(e=>e<0||e>255))throw Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(o,Number);case"uint32":if(o.some(e=>e<0))throw Error("Can not convert int32 data to uint32 - negative value found.");return new Uint8Array(Uint32Array.from(o,Number).buffer);default:throw Error(`Unsupported data conversion from 'int32' to ${r}`)}},e2=1,e3=()=>e2++,e4=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),e6=(e,r)=>{let n=eQ.get(e);if(!n)throw Error(`WebNN backend does not support data type: ${e}`);return r.length>0?Math.ceil(r.reduce((e,r)=>e*r)*n/8):0},e8=class{constructor(e){this.isDataConverted=!1;let{sessionId:r,context:n,tensor:o,dataType:a,shape:s,fallbackDataType:i}=e;this.sessionId=r,this.mlContext=n,this.mlTensor=o,this.dataType=a,this.tensorShape=s,this.fallbackDataType=i}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return e6(this.dataType,this.tensorShape)}destroy(){eK("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){if(!this.fallbackDataType)return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor);{let r=e1(new Uint8Array(await this.mlContext.readTensor(this.mlTensor)),this.dataType);return e?void(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(r):r.buffer}}canReuseTensor(e,r,n){return this.mlContext===e&&this.dataType===r&&this.tensorShape.length===n.length&&this.tensorShape.every((e,r)=>e===n[r])}setIsDataConverted(e){this.isDataConverted=e}},e5=class{constructor(e,r){this.tensorManager=e,this.wrapper=r}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,r,n,o){let a=this.tensorManager.getMLContext(e),s;if(!a.opSupportLimits().input.dataTypes.includes(r)){if(!(s=e4.get(r))||!a.opSupportLimits().input.dataTypes.includes(s))throw Error(`WebNN backend does not support data type: ${r}`);eK("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${r} to ${s}`)}if(this.wrapper){if(this.wrapper.canReuseTensor(a,r,n))return this.wrapper.tensor;if(o){if(this.wrapper.byteLength!==e6(r,n))throw Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let i=typeof MLTensorUsage>"u"?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,r,n,i,!0,!0,s),o&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let r=e;if(this.wrapper){if(this.wrapper.fallbackType)if("int32"===this.wrapper.fallbackType)r=e0(e,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(r);eK("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(r):this.activeUpload=new Uint8Array(r)}async download(e){if(this.activeUpload){let r=this.wrapper?.isDataConverted?e1(this.activeUpload,this.wrapper?.type):this.activeUpload;return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(r):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(r)):r.buffer}if(!this.wrapper)throw Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},e9=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let r=this.backend.getMLContext(e);if(!r)throw Error("MLContext not found for session.");return r}reserveTensorId(){let e=e3();return this.tensorTrackersById.set(e,new e5(this)),e}releaseTensorId(e){let r=this.tensorTrackersById.get(e);r&&(this.tensorTrackersById.delete(e),r.tensorWrapper&&this.releaseTensor(r.tensorWrapper))}async ensureTensor(e,r,n,o,a){eK("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${r}, dataType: ${n}, shape: ${o}, copyOld: ${a}}`);let s=this.tensorTrackersById.get(r);if(!s)throw Error("Tensor not found.");return s.ensureTensor(e,n,o,a)}upload(e,r){let n=this.tensorTrackersById.get(e);if(!n)throw Error("Tensor not found.");n.upload(r)}async download(e,r){eK("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${r?.byteLength}}`);let n=this.tensorTrackersById.get(e);if(!n)throw Error("Tensor not found.");return n.download(r)}releaseTensorsForSession(e){for(let r of this.freeTensors)r.sessionId===e&&r.destroy();this.freeTensors=this.freeTensors.filter(r=>r.sessionId!==e)}registerTensor(e,r,n,o){let a=this.getMLContext(e),s=e3(),i=new e8({sessionId:e,context:a,tensor:r,dataType:n,shape:o});return this.tensorTrackersById.set(s,new e5(this,i)),this.externalTensors.add(i),s}async getCachedTensor(e,r,n,o,a,s,i){let u=this.getMLContext(e);for(let[o,a]of this.freeTensors.entries())if(a.canReuseTensor(u,r,n)){eK("verbose",()=>`[WebNN] Reusing tensor {dataType: ${r}, ${i?`fallbackDataType: ${i},`:""} shape: ${n}`);let a=this.freeTensors.splice(o,1)[0];return a.sessionId=e,a}eK("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${r}, ${i?`fallbackDataType: ${i},`:""} shape: ${n}}`);let l=await u.createTensor({dataType:i??r,shape:n,dimensions:n,usage:o,writable:a,readable:s});return new e8({sessionId:e,context:u,tensor:l,dataType:r,shape:n,fallbackDataType:i})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},e7=(...e)=>new e9(...e)}),tf={};W(tf,{WebNNBackend:()=>tc});var td,tc,th,ty,tm,tg,tw,tb,tv,tT,tE,tI,tC,tA,tx,tO,tU,tL,t$,tR,tM,tN,tB,tS,tk,tP,t_,tG,tD,tW,tF,tj,tV,tz,tH=D(()=>{"use strict";ts(),tr(),tu(),tp(),tl(),td=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),tc=class{constructor(e){this.tensorManager=e7(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,eJ(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw Error("No active session");return this.activeSessionId}onRunStart(e){eK("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){eK("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let r=this.temporarySessionTensorIds.get(e);if(r){for(let e of r)eK("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let r=this.mlContextCache.findIndex(r=>r.gpuDevice===e);if(-1!==r)return this.mlContextCache[r].mlContext;{let r=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:r}),r}}if(void 0===e){let e=this.mlContextCache.findIndex(e=>void 0===e.options&&void 0===e.gpuDevice);if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let r=this.mlContextCache.findIndex(r=>((e,r)=>{if(e===r)return!0;if(void 0===e||void 0===r)return!1;let n=Object.keys(e).sort(),o=Object.keys(r).sort();return n.length===o.length&&n.every((n,a)=>n===o[a]&&e[n]===r[n])})(r.options,e));if(-1!==r)return this.mlContextCache[r].mlContext;{let r=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:r}),r}}registerMLContext(e,r){this.mlContextBySessionId.set(e,r);let n=this.sessionIdsByMLContext.get(r);n||(n=new Set,this.sessionIdsByMLContext.set(r,n)),n.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(e,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e),this.sessionGraphOutputs.delete(e);let r=this.mlContextBySessionId.get(e);if(!r)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let n=this.sessionIdsByMLContext.get(r);if(n.delete(e),0===n.size){this.sessionIdsByMLContext.delete(r);let e=this.mlContextCache.findIndex(e=>e.mlContext===r);-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){eK("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,r,n,o,a){let s=td.get(n);if(!s)throw Error(`Unsupported ONNX data type: ${n}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,r,s,o,a)}async createTemporaryTensor(e,r,n){eK("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${r}, shape: ${n}}`);let o=td.get(r);if(!o)throw Error(`Unsupported ONNX data type: ${r}`);let a=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,a,o,n,!1);let s=this.temporarySessionTensorIds.get(e);return s?s.push(a):this.temporarySessionTensorIds.set(e,[a]),a}uploadTensor(e,r){if(!eL().shouldTransferToMLTensor)throw Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");eK("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${r.byteLength}}`),this.tensorManager.upload(e,r)}async downloadTensor(e,r){return this.tensorManager.download(e,r)}createMLTensorDownloader(e,r){return async()=>{let n=await this.tensorManager.download(e);return eq(n,r)}}registerMLTensor(e,r,n,o){let a=td.get(n);if(!a)throw Error(`Unsupported ONNX data type: ${n}`);let s=this.tensorManager.registerTensor(e,r,a,o);return eK("verbose",()=>`[WebNN] registerMLTensor {tensor: ${r}, dataType: ${a}, dimensions: ${o}} -> {tensorId: ${s}}`),s}registerMLConstant(e,r,n,o,a,s,i=!1){if(!s)throw Error("External mounted files are not available.");let u=e;e.startsWith("./")&&(u=e.substring(2));let l=s.get(u);if(!l)throw Error(`File with name ${u} not found in preloaded files.`);if(r+n>l.byteLength)throw Error("Out of bounds: data offset and length exceed the external file data size.");let p=l.slice(r,r+n).buffer,f;switch(a.dataType){case"float32":f=new Float32Array(p);break;case"float16":f="u">typeof Float16Array&&Float16Array.from?new Float16Array(p):new Uint16Array(p);break;case"int32":f=new Int32Array(p);break;case"uint32":f=new Uint32Array(p);break;case"int64":i?(f=new Int32Array(e0(new Uint8Array(p),"int64").buffer),a.dataType="int32"):f=new BigInt64Array(p);break;case"uint64":f=new BigUint64Array(p);break;case"int8":f=new Int8Array(p);break;case"int4":case"uint4":case"uint8":f=new Uint8Array(p);break;default:throw Error(`Unsupported data type: ${a.dataType} in creating WebNN Constant from external data.`)}return eK("verbose",()=>`[WebNN] registerMLConstant {dataType: ${a.dataType}, shape: ${a.shape}}} ${i?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),o.constant(a,f)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}registerGraphOutput(e){this.temporaryGraphOutputs.push(e)}isGraphInput(e,r){let n=this.sessionGraphInputs.get(e);return!!n&&n.includes(r)}isGraphOutput(e,r){let n=this.sessionGraphOutputs.get(e);return!!n&&n.includes(r)}isGraphInputOutputTypeSupported(e,r,n=!0){let o=this.mlContextBySessionId.get(e),a=td.get(e_(r));return!(typeof a>"u")&&(n?!!o?.opSupportLimits().input.dataTypes.includes(a):!!o?.opSupportLimits().output.dataTypes.includes(a))}flush(){}}}),tq=D(()=>{"use strict";eu(),to(),ta(),ts(),tr(),tn(),ti(),th=async e=>{var r,n;r=e.wasm.numThreads,n=eF(e.logLevel),0!==eL()._OrtInit(r,n)&&eM("Can't initialize onnxruntime.")},ty=async(e,r)=>{eL().asyncInit?.();let n=e.webgpu.adapter;if("webgpu"===r){if(typeof navigator>"u"||!navigator.gpu)throw Error("WebGPU is not supported in current environment");if(n){if("object"!=typeof n.limits||"object"!=typeof n.features||"function"!=typeof n.requestDevice)throw Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let r=e.webgpu.powerPreference;if(void 0!==r&&"low-power"!==r&&"high-performance"!==r)throw Error(`Invalid powerPreference setting: "${r}"`);let o=e.webgpu.forceFallbackAdapter;if(void 0!==o&&"boolean"!=typeof o)throw Error(`Invalid forceFallbackAdapter setting: "${o}"`);if(!(n=await navigator.gpu.requestAdapter({powerPreference:r,forceFallbackAdapter:o})))throw Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if("webnn"===r&&(typeof navigator>"u"||!navigator.ml))throw Error("WebNN is not supported in current environment");if("webgpu"===r&&eL().webgpuInit(r=>{e.webgpu.device=r}),"webnn"===r){let r=new(tH(),F(tf)).WebNNBackend(e);eL().webnnInit([r,()=>r.reserveTensorId(),e=>r.releaseTensorId(e),async(e,n,o,a,s)=>r.ensureTensor(e,n,o,a,s),(e,n)=>{r.uploadTensor(e,n)},async(e,n)=>r.downloadTensor(e,n),(e,n)=>r.registerMLContext(e,n),!!e.trace])}},tm=new Map,tg=(e,r)=>{let n=eL(),o=n.stackSave(),a=0;try{let o=n.PTR_SIZE,s=n.stackAlloc(2*o);0!==n._OrtGetInputOutputMetadata(e,r,s,s+o)&&eM("Can't get session input/output metadata.");let i=Number(n.getValue(s,"*"));a=Number(n.getValue(s+o,"*"));let u=n.HEAP32[a/4];if(0===u)return[i,0];let l=n.HEAPU32[a/4+1],p=[];for(let e=0;e<l;e++){let r=Number(n.getValue(a+8+e*o,"*"));p.push(0!==r?n.UTF8ToString(r):Number(n.getValue(a+8+(e+l)*o,"*")))}return[i,u,p]}finally{n.stackRestore(o),0!==a&&n._OrtFree(a)}},tw=e=>{let r=eL(),n=r._malloc(e.byteLength);if(0===n)throw Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return r.HEAPU8.set(e,n),[n,e.byteLength]},tb=async(e,r)=>{let n,o,a=eL();Array.isArray(e)?[n,o]=e:e.buffer===a.HEAPU8.buffer?[n,o]=[e.byteOffset,e.byteLength]:[n,o]=tw(e);let s=0,i=0,u=0,l=[],p=[],f=[];try{if([i,l]=await eP(r),r?.externalData&&a.mountExternalData){let e=[];for(let n of r.externalData){let r="string"==typeof n?n:n.path;e.push(eH("string"==typeof n?n:n.data).then(e=>{a.mountExternalData(r,e)}))}await Promise.all(e)}for(let e of r?.executionProviders??[])if(("string"==typeof e?e:e.name)==="webnn"){if(a.shouldTransferToMLTensor=!1,"string"!=typeof e){let r=e?.context,n=e?.gpuDevice,o=e?.deviceType,s=e?.powerPreference;r?a.currentContext=r:n?a.currentContext=await a.webnnCreateMLContext(n):a.currentContext=await a.webnnCreateMLContext({deviceType:o,powerPreference:s})}else a.currentContext=await a.webnnCreateMLContext();break}s=await a._OrtCreateSession(n,o,i),a.webgpuOnCreateSession?.(s),0===s&&eM("Can't create a session."),a.jsepOnCreateSession?.(),a.currentContext&&(a.webnnRegisterMLContext(s,a.currentContext),a.currentContext=void 0,a.shouldTransferToMLTensor=!0);let[e,d]=(e=>{let r=eL(),n=r.stackSave();try{let n=r.PTR_SIZE,o=r.stackAlloc(2*n);0!==r._OrtGetInputOutputCount(e,o,o+n)&&eM("Can't get session input/output count.");let a=4===n?"i32":"i64";return[Number(r.getValue(o,a)),Number(r.getValue(o+n,a))]}finally{r.stackRestore(n)}})(s),c=!!r?.enableGraphCapture,h=[],y=[],m=[],g=[],w=[];for(let r=0;r<e;r++){let[e,n,o]=tg(s,r);0===e&&eM("Can't get an input name."),p.push(e);let i=a.UTF8ToString(e);h.push(i),m.push(0===n?{name:i,isTensor:!1}:{name:i,isTensor:!0,type:eG(n),shape:o})}for(let n=0;n<d;n++){let[o,i,u]=tg(s,n+e);0===o&&eM("Can't get an output name."),f.push(o);let l=a.UTF8ToString(o);y.push(l),g.push(0===i?{name:l,isTensor:!1}:{name:l,isTensor:!0,type:eG(i),shape:u});{if(c&&r?.preferredOutputLocation===void 0){w.push("gpu-buffer");continue}let e="string"==typeof r?.preferredOutputLocation?r.preferredOutputLocation:r?.preferredOutputLocation?.[l]??"cpu",n=a.webnnIsGraphOutput;if("cpu"===e&&n&&n(s,l)){w.push("ml-tensor-cpu-output");continue}if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw Error(`Not supported preferred output location: ${e}.`);if(c&&"gpu-buffer"!==e)throw Error(`Not supported preferred output location: ${e}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);w.push(e)}}let b=null;return w.some(e=>"gpu-buffer"===e||"ml-tensor"===e||"ml-tensor-cpu-output"===e)&&(u=a._OrtCreateBinding(s),0===u&&eM("Can't create IO binding."),b={handle:u,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(e=>"ml-tensor-cpu-output"===e?"ml-tensor":e).map(e=>ez(e))}),tm.set(s,[s,p,f,b,c,!1]),[s,h,y,m,g]}catch(e){throw p.forEach(e=>a._OrtFree(e)),f.forEach(e=>a._OrtFree(e)),0!==u&&0!==a._OrtReleaseBinding(u)&&eM("Can't release IO binding."),0!==s&&0!==a._OrtReleaseSession(s)&&eM("Can't release session."),e}finally{a._free(n),0!==i&&0!==a._OrtReleaseSessionOptions(i)&&eM("Can't release session options."),l.forEach(e=>a._free(e)),a.unmountExternalData?.()}},tv=e=>{let r=eL(),n=tm.get(e);if(!n)throw Error(`cannot release session. invalid session id: ${e}`);let[o,a,s,i,u]=n;i&&(u&&0!==r._OrtClearBoundOutputs(i.handle)&&eM("Can't clear bound outputs."),0!==r._OrtReleaseBinding(i.handle)&&eM("Can't release IO binding.")),r.jsepOnReleaseSession?.(e),r.webnnOnReleaseSession?.(e),r.webgpuOnReleaseSession?.(e),a.forEach(e=>r._OrtFree(e)),s.forEach(e=>r._OrtFree(e)),0!==r._OrtReleaseSession(o)&&eM("Can't release session."),tm.delete(e)},tT=async(e,r,n,o,a,s,i=!1)=>{if(!e)return void r.push(0);let u=eL(),l=u.PTR_SIZE,p=e[0],f=e[1],d=e[3],c=d,h,y;if("string"===p&&("gpu-buffer"===d||"ml-tensor"===d))throw Error("String tensor is not supported on GPU.");if(i&&"gpu-buffer"!==d)throw Error(`External buffer must be provided for input/output index ${s} when enableGraphCapture is true.`);if("gpu-buffer"===d){let r=e[2].gpuBuffer;y=eD(e_(p),f);{let e=u.webgpuRegisterBuffer;if(!e)throw Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');h=e(r,o)}}else if("ml-tensor"===d){let r=e[2].mlTensor;y=eD(e_(p),f);let n=u.webnnRegisterMLTensor;if(!n)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');h=n(o,r,e_(p),f)}else{let r=e[2];if(Array.isArray(r)){y=l*r.length,h=u._malloc(y),n.push(h);for(let e=0;e<r.length;e++){if("string"!=typeof r[e])throw TypeError(`tensor data at index ${e} is not a string`);u.setValue(h+e*l,e$(r[e],n),"*")}}else{let e=u.webnnIsGraphInput,s=u.webnnIsGraphOutput;if("string"!==p&&e&&s){let i=u.UTF8ToString(a);if(e(o,i)||s(o,i)){let e=e_(p);y=eD(e,f),c="ml-tensor";let n=u.webnnCreateTemporaryTensor,a=u.webnnUploadTensor;if(!n||!a)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');let s=await n(o,e,f);a(s,new Uint8Array(r.buffer,r.byteOffset,r.byteLength)),h=s}else y=r.byteLength,h=u._malloc(y),n.push(h),u.HEAPU8.set(new Uint8Array(r.buffer,r.byteOffset,y),h)}else y=r.byteLength,h=u._malloc(y),n.push(h),u.HEAPU8.set(new Uint8Array(r.buffer,r.byteOffset,y),h)}}let m=u.stackSave(),g=u.stackAlloc(4*f.length);try{f.forEach((e,r)=>u.setValue(g+r*l,e,4===l?"i32":"i64"));let e=u._OrtCreateTensor(e_(p),h,y,g,f.length,ez(c));0===e&&eM(`Can't create tensor for input/output. session=${o}, index=${s}.`),r.push(e)}finally{u.stackRestore(m)}},tE=async(e,r,n,o,a,s)=>{let i=eL(),u=i.PTR_SIZE,l=tm.get(e);if(!l)throw Error(`cannot run inference. invalid session id: ${e}`);let p=l[0],f=l[1],d=l[2],c=l[3],h=l[4],y=l[5],m=r.length,g=o.length,w=0,b=[],v=[],T=[],E=[],I=i.stackSave(),C=i.stackAlloc(m*u),A=i.stackAlloc(m*u),x=i.stackAlloc(g*u),O=i.stackAlloc(g*u);try{let l;[w,b]=eN(s),S("wasm prepareInputOutputTensor");for(let o=0;o<m;o++)await tT(n[o],v,E,e,f[r[o]],r[o],h);for(let r=0;r<g;r++)await tT(a[r],T,E,e,d[o[r]],m+o[r],h);k("wasm prepareInputOutputTensor");for(let e=0;e<m;e++)i.setValue(C+e*u,v[e],"*"),i.setValue(A+e*u,f[r[e]],"*");for(let e=0;e<g;e++)i.setValue(x+e*u,T[e],"*"),i.setValue(O+e*u,d[o[e]],"*");if(c&&!y){let{handle:n,outputPreferredLocations:s,outputPreferredLocationsEncoded:u}=c;if(f.length!==m)throw Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${f.length}).`);S("wasm bindInputsOutputs");for(let o=0;o<m;o++){let a=r[o];await i._OrtBindInput(n,f[a],v[o])!==0&&eM(`Can't bind input[${o}] for session=${e}.`)}for(let r=0;r<g;r++){let l=o[r];a[r]?.[3]?0!==i._OrtBindOutput(n,d[l],T[r],0)&&eM(`Can't bind pre-allocated output[${r}] for session=${e}.`):0!==i._OrtBindOutput(n,d[l],0,u[l])&&eM(`Can't bind output[${r}] to ${s[r]} for session=${e}.`)}k("wasm bindInputsOutputs"),tm.set(e,[p,f,d,c,h,!0])}i.jsepOnRunStart?.(p),i.webnnOnRunStart?.(p),l=c?await i._OrtRunWithBinding(p,c.handle,g,x,w):await i._OrtRun(p,A,C,m,O,g,x,w),0!==l&&eM("failed to call OrtRun().");let I=[],U=[];S("wasm ProcessOutputTensor");for(let r=0;r<g;r++){let n=Number(i.getValue(x+r*u,"*"));if(n===T[r]){I.push(a[r]);continue}let s=i.stackSave(),l=i.stackAlloc(4*u),p=!1,f,d=0;try{0!==i._OrtGetTensorData(n,l,l+u,l+2*u,l+3*u)&&eM(`Can't access output tensor data on index ${r}.`);let a=4===u?"i32":"i64",s=Number(i.getValue(l,a));d=i.getValue(l+u,"*");let h=i.getValue(l+2*u,"*"),y=Number(i.getValue(l+3*u,a)),m=[];for(let e=0;e<y;e++)m.push(Number(i.getValue(h+e*u,a)));0!==i._OrtFree(h)&&eM("Can't free memory for tensor dims.");let g=m.reduce((e,r)=>e*r,1);f=eG(s);let w=c?.outputPreferredLocations[o[r]];if("string"===f){if("gpu-buffer"===w||"ml-tensor"===w)throw Error("String tensor is not supported on GPU.");let e=[];for(let r=0;r<g;r++){let n=i.getValue(d+r*u,"*"),o=i.getValue(d+(r+1)*u,"*"),a=r===g-1?void 0:o-n;e.push(i.UTF8ToString(n,a))}I.push([f,m,e,"cpu"])}else if("gpu-buffer"===w&&g>0){let r=i.webgpuGetBuffer;if(!r)throw Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let o=r(d),a=eD(s,g);if(void 0===a||!ej(f))throw Error(`Unsupported data type: ${f}`);p=!0;{i.webgpuRegisterBuffer(o,e,d);let r=i.webgpuCreateDownloader(o,a,e);I.push([f,m,{gpuBuffer:o,download:async()=>{let e=await r();return new(eW(f))(e)},dispose:()=>{0!==i._OrtReleaseTensor(n)&&eM("Can't release tensor.")}},"gpu-buffer"])}}else if("ml-tensor"===w&&g>0){let r=i.webnnEnsureTensor,o=i.webnnIsGraphInputOutputTypeSupported;if(!r||!o)throw Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===eD(s,g)||!eV(f))throw Error(`Unsupported data type: ${f}`);if(!o(e,f,!1))throw Error(`preferredLocation "ml-tensor" for ${f} output is not supported by current WebNN Context.`);let a=await r(e,d,s,m,!1);p=!0,I.push([f,m,{mlTensor:a,download:i.webnnCreateMLTensorDownloader(d,f),dispose:()=>{i.webnnReleaseTensorId(d),i._OrtReleaseTensor(n)}},"ml-tensor"])}else if("ml-tensor-cpu-output"===w&&g>0){let e=i.webnnCreateMLTensorDownloader(d,f)(),r=I.length;p=!0,U.push((async()=>{let o=[r,await e];return i.webnnReleaseTensorId(d),i._OrtReleaseTensor(n),o})()),I.push([f,m,[],"cpu"])}else{let e=new(eW(f))(g);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(i.HEAPU8.subarray(d,d+e.byteLength)),I.push([f,m,e,"cpu"])}}finally{i.stackRestore(s),"string"===f&&d&&i._free(d),p||i._OrtReleaseTensor(n)}}for(let[r,n]of(c&&!h&&(0!==i._OrtClearBoundOutputs(c.handle)&&eM("Can't clear bound outputs."),tm.set(e,[p,f,d,c,h,!1])),await Promise.all(U)))I[r][2]=n;return k("wasm ProcessOutputTensor"),I}finally{i.webnnOnRunEnd?.(p),i.stackRestore(I),n.forEach(e=>{e&&"gpu-buffer"===e[3]&&i.webgpuUnregisterBuffer(e[2].gpuBuffer)}),a.forEach(e=>{e&&"gpu-buffer"===e[3]&&i.webgpuUnregisterBuffer(e[2].gpuBuffer)}),v.forEach(e=>i._OrtReleaseTensor(e)),T.forEach(e=>i._OrtReleaseTensor(e)),E.forEach(e=>i._free(e)),0!==w&&i._OrtReleaseRunOptions(w),b.forEach(e=>i._free(e))}},tI=e=>{let r=eL(),n=tm.get(e);if(!n)throw Error("invalid session id");let o=n[0],a=r._OrtEndProfiling(o);0===a&&eM("Can't get an profile file name."),r._OrtFree(a)},tC=e=>{let r=[];for(let n of e){let e=n[2];!Array.isArray(e)&&"buffer"in e&&r.push(e.buffer)}return r}}),tZ=D(()=>{"use strict";eu(),tq(),tr(),tt(),tA=()=>!!h.wasm.proxy&&"u">typeof document,tO=!1,tU=!1,tL=!1,tM=new Map,tN=(e,r)=>{let n=tM.get(e);n?n.push(r):tM.set(e,[r])},tB=()=>{if(tO||!tU||tL||!tx)throw Error("worker not ready")},tS=e=>{switch(e.data.type){case"init-wasm":tO=!1,e.data.err?(tL=!0,tR[1](e.data.err)):(tU=!0,tR[0]()),t$&&(URL.revokeObjectURL(t$),t$=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=tM.get(e.data.type);e.data.err?r.shift()[1](e.data.err):r.shift()[0](e.data.out)}}},tk=async()=>{if(!tU){if(tO)throw Error("multiple calls to 'initWasm()' detected.");if(tL)throw Error("previous call to 'initWasm()' failed.");if(tO=!0,tA())return new Promise((e,r)=>{tx?.terminate(),eT().then(([n,o])=>{try{(tx=o).onerror=e=>r(e),tx.onmessage=tS,tR=[e,r];let a={type:"init-wasm",in:h};if(!a.in.wasm.wasmPaths&&n){let e=em();e&&(a.in.wasm.wasmPaths=e)}tx.postMessage(a),t$=n}catch(e){r(e)}},r)});try{await eU(h.wasm),await th(h),tU=!0}catch(e){throw tL=!0,e}finally{tO=!1}}},tP=async e=>{if(tA())return tB(),new Promise((r,n)=>{tN("init-ep",[r,n]);let o={type:"init-ep",in:{epName:e,env:h}};tx.postMessage(o)});await ty(h,e)},t_=async e=>tA()?(tB(),new Promise((r,n)=>{tN("copy-from",[r,n]),tx.postMessage({type:"copy-from",in:{buffer:e}},[e.buffer])})):tw(e),tG=async(e,r)=>{if(!tA())return tb(e,r);if(r?.preferredOutputLocation)throw Error('session option "preferredOutputLocation" is not supported for proxy.');return tB(),new Promise((n,o)=>{tN("create",[n,o]);let a={type:"create",in:{model:e,options:{...r}}},s=[];e instanceof Uint8Array&&s.push(e.buffer),tx.postMessage(a,s)})},tD=async e=>{if(tA())return tB(),new Promise((r,n)=>{tN("release",[r,n]),tx.postMessage({type:"release",in:e})});tv(e)},tW=async(e,r,n,o,a,s)=>{if(!tA())return tE(e,r,n,o,a,s);if(n.some(e=>"cpu"!==e[3]))throw Error("input tensor on GPU is not supported for proxy.");if(a.some(e=>e))throw Error("pre-allocated output tensor is not supported for proxy.");return tB(),new Promise((a,i)=>{tN("run",[a,i]),tx.postMessage({type:"run",in:{sessionId:e,inputIndices:r,inputs:n,outputIndices:o,options:s}},tC(n))})},tF=async e=>{if(tA())return tB(),new Promise((r,n)=>{tN("end-profiling",[r,n]),tx.postMessage({type:"end-profiling",in:e})});tI(e)}}),tX=D(()=>{"use strict";eu(),tZ(),ts(),el(),ti(),tj=(e,r)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw Error(`invalid data location: ${e.location} for ${r()}`)}},tV=e=>{switch(e[3]){case"cpu":return new $(e[0],e[2],e[1]);case"gpu-buffer":{let r=e[0];if(!ej(r))throw Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:n,download:o,dispose:a}=e[2];return $.fromGpuBuffer(n,{dataType:r,dims:e[1],download:o,dispose:a})}case"ml-tensor":{let r=e[0];if(!eV(r))throw Error(`not supported data type: ${r} for deserializing MLTensor tensor`);let{mlTensor:n,download:o,dispose:a}=e[2];return $.fromMLTensor(n,{dataType:r,dims:e[1],download:o,dispose:a})}default:throw Error(`invalid data location: ${e[3]}`)}},tz=class{async fetchModelAndCopyToWasmMemory(e){return t_(await eH(e))}async loadModel(e,r){let n;N(),n="string"==typeof e?await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await tG(n,r),B()}async dispose(){return tD(this.sessionId)}async run(e,r,n){N();let o=[],a=[];Object.entries(e).forEach(e=>{let r=e[0],n=e[1],s=this.inputNames.indexOf(r);if(-1===s)throw Error(`invalid input '${r}'`);o.push(n),a.push(s)});let s=[],i=[];Object.entries(r).forEach(e=>{let r=e[0],n=e[1],o=this.outputNames.indexOf(r);if(-1===o)throw Error(`invalid output '${r}'`);s.push(n),i.push(o)});let u=o.map((e,r)=>tj(e,()=>`input "${this.inputNames[a[r]]}"`)),l=s.map((e,r)=>e?tj(e,()=>`output "${this.outputNames[i[r]]}"`):null),p=await tW(this.sessionId,a,u,i,l,n),f={};for(let e=0;e<p.length;e++)f[this.outputNames[i[e]]]=s[e]??tV(p[e]);return B(),f}startProfiling(){}endProfiling(){tF(this.sessionId)}}}),tY={};W(tY,{OnnxruntimeWebAssemblyBackend:()=>tK,initializeFlags:()=>tJ,wasmBackend:()=>tQ});var tJ,tK,tQ,t0=D(()=>{"use strict";eu(),tZ(),tX(),tJ=()=>{("number"!=typeof h.wasm.initTimeout||h.wasm.initTimeout<0)&&(h.wasm.initTimeout=0);let e=h.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),h.wasm.simd=!1),"boolean"!=typeof h.wasm.proxy&&(h.wasm.proxy=!1),"boolean"!=typeof h.wasm.trace&&(h.wasm.trace=!1),"number"!=typeof h.wasm.numThreads||!Number.isInteger(h.wasm.numThreads)||h.wasm.numThreads<=0)if("u">typeof self&&!self.crossOriginIsolated)h.wasm.numThreads=1;else{let e=typeof navigator>"u"?G("node:os").cpus().length:navigator.hardwareConcurrency;h.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},tQ=new(tK=class{async init(e){tJ(),await tk(),await tP(e)}async createInferenceSessionHandler(e,r){let n=new tz;return await n.loadModel(e,r),n}})});eu(),eu(),eu();var t1=ei;{let e=(t0(),F(tY)).wasmBackend;u("webgpu",e,5),u("webnn",e,5),u("cpu",e,10),u("wasm",e,10)}Object.defineProperty(h.versions,"web",{value:"1.23.2",enumerable:!0});export{_ as InferenceSession,R as TRACE,S as TRACE_EVENT_BEGIN,k as TRACE_EVENT_END,N as TRACE_FUNC_BEGIN,B as TRACE_FUNC_END,$ as Tensor,t1 as default,h as env,u as registerBackend};