/*! For license information please see ort.wasm.mjs.LICENSE.txt */
let e;var t,r,n,o,a,i,s,l,u,f,d,p,c,m,h,y,w,g,b,v,E,T,A,C,R,O,U,x,L,I,P,$,_,B,N,S,M,k,j,D,G,F,W,V,H,z,q,Z,J,Y,K,Q,X,ee,et,er,en,eo,ea,ei,es,el,eu,ef,ed,ep,ec,em,eh,ey,ew,eg,eb,ev,eE,eT,eA,eC,eR,eO,eU,ex,eL,eI,eP,e$,e_,eB,eN,eS,eM,ek,ej,eD,eG,eF,eW,eV,eH,ez,eq,eZ,eJ,eY,eK=Object.defineProperty,eQ=Object.getOwnPropertyDescriptor,eX=Object.getOwnPropertyNames,e0=Object.prototype.hasOwnProperty,e1=(e=function(e){if("undefined"!=typeof require)return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')},"undefined"!=typeof require?require:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>("undefined"!=typeof require?require:e)[t]}):e),e2=(e,t)=>function(){return e&&(t=(0,e[eX(e)[0]])(e=0)),t},e3=(e,t)=>{for(var r in t)eK(e,r,{get:t[r],enumerable:!0})},e6=e=>((e,t,r,n)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let o of eX(t))e0.call(e,o)||o===r||eK(e,o,{get:()=>t[o],enumerable:!(n=eQ(t,o))||n.enumerable});return e})(eK({},"__esModule",{value:!0}),e),e4=e2({"common/dist/esm/backend-impl.js"(){"use strict";t=new Map,r=[],n=(e,n,o)=>{if(n&&"function"==typeof n.init&&"function"==typeof n.createInferenceSessionHandler){let a=t.get(e);if(void 0===a)t.set(e,{backend:n,priority:o});else if(a.priority>o)return;else if(a.priority===o&&a.backend!==n)throw Error(`cannot register backend "${e}" using priority ${o}`);if(o>=0){let n=r.indexOf(e);-1!==n&&r.splice(n,1);for(let n=0;n<r.length;n++)if(t.get(r[n]).priority<=o)return void r.splice(n,0,e);r.push(e)}return}throw TypeError("not a valid backend")},o=async e=>{let r=t.get(e);if(!r)return"backend not found.";if(r.initialized)return r.backend;{if(r.aborted)return r.error;let t=!!r.initPromise;try{return t||(r.initPromise=r.backend.init(e)),await r.initPromise,r.initialized=!0,r.backend}catch(e){return t||(r.error=`${e}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},a=async e=>{let t,n=e.executionProviders||[],a=n.map(e=>"string"==typeof e?e:e.name),i=0===a.length?r:a,s=[],l=new Set;for(let e of i){let r=await o(e);"string"==typeof r?s.push({name:e,err:r}):(t||(t=r),t===r&&l.add(e))}if(!t)throw Error(`no available backend found. ERR: ${s.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:t}of s)a.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let u=n.filter(e=>l.has("string"==typeof e?e:e.name));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?u:Reflect.get(e,t)})]}}}),e8=e2({"common/dist/esm/backend.js"(){"use strict";e4()}}),e5=e2({"common/dist/esm/version.js"(){"use strict";i="1.23.2"}}),e9=e2({"common/dist/esm/env-impl.js"(){"use strict";e5(),s="warning",Object.defineProperty(l={wasm:{},webgl:{},webgpu:{},versions:{common:i},set logLevel(value){if(void 0===value)return;if("string"!=typeof value||-1===["verbose","info","warning","error","fatal"].indexOf(value))throw Error(`Unsupported logging level: ${value}`);s=value},get logLevel(){return s}},"logLevel",{enumerable:!0})}}),e7=e2({"common/dist/esm/env.js"(){"use strict";e9(),u=l}}),te=e2({"common/dist/esm/tensor-conversion-impl.js"(){"use strict";f=(e,t)=>{let r="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext("2d");if(null!=n){let o,a,i,s;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(o=e.dims[2],a=e.dims[3]):(o=e.dims[3],a=e.dims[2]);let l=t?.format!==void 0?t.format:"RGB",u=t?.norm;void 0===u||void 0===u.mean?i=[255,255,255,255]:"number"==typeof u.mean?i=[u.mean,u.mean,u.mean,u.mean]:(i=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(i[3]=u.mean[3])),void 0===u||void 0===u.bias?s=[0,0,0,0]:"number"==typeof u.bias?s=[u.bias,u.bias,u.bias,u.bias]:(s=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(s[3]=u.bias[3]));let f=a*o,d=0,p=f,c=2*f,m=-1;"RGBA"===l?(d=0,p=f,c=2*f,m=3*f):"RGB"===l?(d=0,p=f,c=2*f):"RBG"===l&&(d=0,c=f,p=2*f);for(let t=0;t<a;t++)for(let r=0;r<o;r++)n.fillStyle="rgba("+(e.data[d++]-s[0])*i[0]+","+(e.data[p++]-s[1])*i[1]+","+(e.data[c++]-s[2])*i[2]+","+(-1===m?255:(e.data[m++]-s[3])*i[3])+")",n.fillRect(r,t,1,1);if("toDataURL"in r)return r.toDataURL();throw Error("toDataURL is not supported")}throw Error("Can not access image data")},d=(e,t)=>{let r,n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null!=n){let o,a,i,s,l;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(o=e.dims[2],a=e.dims[1],i=e.dims[3]):(o=e.dims[3],a=e.dims[2],i=e.dims[1]);let u=void 0!==t&&void 0!==t.format?t.format:"RGB",f=t?.norm;void 0===f||void 0===f.mean?s=[255,255,255,255]:"number"==typeof f.mean?s=[f.mean,f.mean,f.mean,f.mean]:(s=[f.mean[0],f.mean[1],f.mean[2],255],void 0!==f.mean[3]&&(s[3]=f.mean[3])),void 0===f||void 0===f.bias?l=[0,0,0,0]:"number"==typeof f.bias?l=[f.bias,f.bias,f.bias,f.bias]:(l=[f.bias[0],f.bias[1],f.bias[2],0],void 0!==f.bias[3]&&(l[3]=f.bias[3]));let d=a*o;if(void 0!==t&&(void 0!==t.format&&4===i&&"RGBA"!==t.format||3===i&&"RGB"!==t.format&&"BGR"!==t.format))throw Error("Tensor format doesn't match input tensor dims");let p=0,c=1,m=2,h=3,y=0,w=d,g=2*d,b=-1;"RGBA"===u?(y=0,w=d,g=2*d,b=3*d):"RGB"===u?(y=0,w=d,g=2*d):"RBG"===u&&(y=0,g=d,w=2*d),r=n.createImageData(o,a);for(let t=0;t<a*o;p+=4,c+=4,m+=4,h+=4,t++)r.data[p]=(e.data[y++]-l[0])*s[0],r.data[c]=(e.data[w++]-l[1])*s[1],r.data[m]=(e.data[g++]-l[2])*s[2],r.data[h]=-1===b?255:(e.data[b++]-l[3])*s[3]}else throw Error("Can not access image data");return r}}}),tt=e2({"common/dist/esm/tensor-factory-impl.js"(){"use strict";to(),p=(e,t)=>{let r,n;if(void 0===e)throw Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:o,width:a}=t,i=t.norm??{mean:255,bias:0};r="number"==typeof i.mean?[i.mean,i.mean,i.mean,i.mean]:[i.mean[0],i.mean[1],i.mean[2],i.mean[3]??255],n="number"==typeof i.bias?[i.bias,i.bias,i.bias,i.bias]:[i.bias[0],i.bias[1],i.bias[2],i.bias[3]??0];let s=void 0!==t.format?t.format:"RGBA",l=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",u=o*a,f=new Float32Array("RGBA"===l?4*u:3*u),d=4,p=0,c=1,m=2,h=3,y=0,w=u,g=2*u,b=-1;"RGB"===s&&(d=3,p=0,c=1,m=2,h=-1),"RGBA"===l?b=3*u:"RBG"===l?(y=0,g=u,w=2*u):"BGR"===l&&(g=0,w=u,y=2*u);for(let t=0;t<u;t++,p+=d,m+=d,c+=d,h+=d)f[y++]=(e[p]+n[0])/r[0],f[w++]=(e[c]+n[1])/r[1],f[g++]=(e[m]+n[2])/r[2],-1!==b&&-1!==h&&(f[b++]=(e[h]+n[3])/r[3]);return"RGBA"===l?new C("float32",f,[1,4,o,a]):new C("float32",f,[1,3,o,a])},c=async(e,t)=>{let r,n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,o="undefined"!=typeof ImageData&&e instanceof ImageData,a="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,i="string"==typeof e,s=t??{},l=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},u=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){let n=l();n.width=e.width,n.height=e.height;let o=u(n);if(null!=o){let n=e.height,a=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,a=t.resizedWidth),void 0!==t){if(s=t,void 0!==t.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");s.tensorFormat="RGBA",s.height=n,s.width=a}else s.tensorFormat="RGBA",s.height=n,s.width=a;o.drawImage(e,0,0),r=o.getImageData(0,0,a,n).data}else throw Error("Can not access image data")}else if(o){let n,o;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,o=t.resizedWidth):(n=e.height,o=e.width),void 0!==t&&(s=t),s.format="RGBA",s.height=n,s.width=o,void 0!==t){let t=l();t.width=o,t.height=n;let a=u(t);if(null!=a)a.putImageData(e,0,0),r=a.getImageData(0,0,o,n).data;else throw Error("Can not access image data")}else r=e.data}else if(a){if(void 0===t)throw Error("Please provide image config with format for Imagebitmap");let n=l();n.width=e.width,n.height=e.height;let o=u(n);if(null!=o){let t=e.height,n=e.width;return o.drawImage(e,0,0,n,t),r=o.getImageData(0,0,n,t).data,s.height=t,s.width=n,p(r,s)}throw Error("Can not access image data")}else if(i)return new Promise((t,r)=>{let n=l(),o=u(n);if(!e||!o)return r();let a=new Image;a.crossOrigin="Anonymous",a.src=e,a.onload=()=>{n.width=a.width,n.height=a.height,o.drawImage(a,0,0,n.width,n.height);let e=o.getImageData(0,0,n.width,n.height);s.height=n.height,s.width=n.width,t(p(e.data,s))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==r)return p(r,s);throw Error("Input data provided is not supported - aborted tensor creation")},m=(e,t)=>{let{width:r,height:n,download:o,dispose:a}=t;return new C({location:"texture",type:"float32",texture:e,dims:[1,n,r,4],download:o,dispose:a})},h=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:a}=t;return new C({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:n,download:o,dispose:a})},y=(e,t)=>{let{dataType:r,dims:n,download:o,dispose:a}=t;return new C({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:n,download:o,dispose:a})},w=(e,t,r)=>new C({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})}}),tr=e2({"common/dist/esm/tensor-impl-type-mapping.js"(){"use strict";g=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),b=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),v=!1,E=()=>{if(!v){v=!0;let e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,r=globalThis.Float16Array,n=void 0!==r&&r.from;e&&(g.set("int64",BigInt64Array),b.set(BigInt64Array,"int64")),t&&(g.set("uint64",BigUint64Array),b.set(BigUint64Array,"uint64")),n?(g.set("float16",r),b.set(r,"float16")):g.set("float16",Uint16Array)}}}}),tn=e2({"common/dist/esm/tensor-utils-impl.js"(){"use strict";to(),T=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},A=(e,t)=>{switch(e.location){case"cpu":return new C(e.type,e.data,t);case"cpu-pinned":return new C({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new C({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new C({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new C({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}}),to=e2({"common/dist/esm/tensor-impl.js"(){"use strict";te(),tt(),tr(),tn(),C=class{constructor(e,t,r){let n,o;if(E(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,n=e.type,o=e.dims,e.location){case"cpu-pinned":{let t=g.get(n);if(!t)throw TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==n)throw TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint64"!==n&&"int8"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let a,i;if("string"==typeof e)if(n=e,i=r,"string"===e){if(!Array.isArray(t))throw TypeError("A string tensor's data must be a string array.");a=t}else{let r=g.get(e);if(void 0===r)throw TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))if("float16"===e&&r===Uint16Array||"uint4"===e||"int4"===e)throw TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${r.name} as data.`);else a="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t);else if(t instanceof r)a=t;else if(t instanceof Uint8ClampedArray)if("uint8"===e)a=Uint8Array.from(t);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if("float16"===e&&t instanceof Uint16Array&&r!==Uint16Array)a=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw TypeError(`A ${n} tensor's data must be type of ${r}`)}else if(i=t,Array.isArray(e)){if(0===e.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)n="string",a=e;else if("boolean"===t)n="bool",a=Uint8Array.from(e);else throw TypeError(`Invalid element type of data array: ${t}.`)}else if(e instanceof Uint8ClampedArray)n="uint8",a=Uint8Array.from(e);else{let t=b.get(e.constructor);if(void 0===t)throw TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,a=e}if(void 0===i)i=[a.length];else if(!Array.isArray(i))throw TypeError("A tensor's dims must be a number array");o=i,this.cpuData=a,this.dataLocation="cpu"}let a=T(o);if(this.cpuData&&a!==this.cpuData.length)if(("uint4"===n||"int4"===n)&&Math.ceil(a/2)===this.cpuData.length);else throw Error(`Tensor's size(${a}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=o,this.size=a}static async fromImage(e,t){return c(e,t)}static fromTexture(e,t){return m(e,t)}static fromGpuBuffer(e,t){return h(e,t)}static fromMLTensor(e,t){return y(e,t)}static fromPinnedBuffer(e,t,r){return w(e,t,r)}toDataURL(e){return f(this,e)}toImageData(e){return d(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");return A(this,e)}}}}),ta=e2({"common/dist/esm/tensor.js"(){"use strict";to(),R=C}}),ti=e2({"common/dist/esm/trace.js"(){"use strict";e9(),O=(e,t)=>{(void 0===l.trace?l.wasm.trace:l.trace)&&console.timeStamp(`${e}::ORT::${t}`)},U=(e,t)=>{let r=Error().stack?.split(/\r\n|\r|\n/g)||[],n=!1;for(let o=0;o<r.length;o++){if(n&&!r[o].includes("TRACE_FUNC")){let n=`FUNC_${e}::${r[o].trim().split(" ")[1]}`;t&&(n+=`::${t}`),O("CPU",n);return}r[o].includes("TRACE_FUNC")&&(n=!0)}},x=e=>{(void 0===l.trace?l.wasm.trace:l.trace)&&U("BEGIN",e)},L=e=>{(void 0===l.trace?l.wasm.trace:l.trace)&&U("END",e)},I=e=>{(void 0===l.trace?l.wasm.trace:l.trace)&&console.time(`ORT::${e}`)},P=e=>{(void 0===l.trace?l.wasm.trace:l.trace)&&console.timeEnd(`ORT::${e}`)}}}),ts=e2({"common/dist/esm/inference-session-impl.js"(){"use strict";e4(),ta(),ti(),$=class e{constructor(e){this.handler=e}async run(e,t,r){x(),I("InferenceSession.run");let n={},o={};if("object"!=typeof e||null===e||e instanceof R||Array.isArray(e))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let a=!0;if("object"==typeof t){if(null===t)throw TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof R)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw TypeError("'fetches' cannot be an empty array.");for(let e of(a=!1,t)){if("string"!=typeof e)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else{let e=!1,i=Object.getOwnPropertyNames(t);for(let r of this.outputNames)if(-1!==i.indexOf(r)){let o=t[r];(null===o||o instanceof R)&&(e=!0,a=!1,n[r]=o)}if(e){if("object"==typeof r&&null!==r)o=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else o=t}}else if(void 0!==t)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(void 0===e[t])throw Error(`input '${t}' is missing in 'feeds'.`);if(a)for(let e of this.outputNames)n[e]=null;let i=await this.handler.run(e,n,o),s={};for(let e in i)if(Object.hasOwnProperty.call(i,e)){let t=i[e];t instanceof R?s[e]=t:s[e]=new R(t.type,t.data,t.dims)}return P("InferenceSession.run"),L(),s}async release(){return this.handler.dispose()}static async create(t,r,n,o){let i;x(),I("InferenceSession.create");let s={};if("string"==typeof t){if(i=t,"object"==typeof r&&null!==r)s=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(i=t,"object"==typeof r&&null!==r)s=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer){let e=0,a=t.byteLength;if("object"==typeof r&&null!==r)s=r;else if("number"==typeof r){if(!Number.isSafeInteger(e=r))throw RangeError("'byteOffset' must be an integer.");if(e<0||e>=t.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${t.byteLength}).`);if(a=t.byteLength-e,"number"==typeof n){if(!Number.isSafeInteger(a=n))throw RangeError("'byteLength' must be an integer.");if(a<=0||e+a>t.byteLength)throw RangeError(`'byteLength' is out of range (0, ${t.byteLength-e}].`);if("object"==typeof o&&null!==o)s=o;else if(void 0!==o)throw TypeError("'options' must be an object.")}else if(void 0!==n)throw TypeError("'byteLength' must be a number.")}else if(void 0!==r)throw TypeError("'options' must be an object.");i=new Uint8Array(t,e,a)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[l,u]=await a(s),f=await l.createInferenceSessionHandler(i,u);return P("InferenceSession.create"),L(),new e(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}}),tl=e2({"common/dist/esm/inference-session.js"(){"use strict";ts(),_=$}}),tu=e2({"common/dist/esm/tensor-conversion.js"(){}}),tf=e2({"common/dist/esm/tensor-factory.js"(){}}),td=e2({"common/dist/esm/onnx-model.js"(){}}),tp=e2({"common/dist/esm/onnx-value.js"(){}}),tc={};e3(tc,{InferenceSession:()=>_,TRACE:()=>O,TRACE_EVENT_BEGIN:()=>I,TRACE_EVENT_END:()=>P,TRACE_FUNC_BEGIN:()=>x,TRACE_FUNC_END:()=>L,Tensor:()=>R,env:()=>u,registerBackend:()=>n});var tm=e2({"common/dist/esm/index.js"(){"use strict";e8(),e7(),tl(),ta(),tu(),tf(),ti(),td(),tp()}}),th=e2({"web/lib/wasm/wasm-utils-env.ts"(){"use strict";B=!1}}),ty={};e3(ty,{default:()=>S});var tw=e2({"web/lib/wasm/proxy-worker/main.ts"(){"use strict";tR(),tb(),tg(),(N=globalThis.self?.name==="ort-wasm-proxy-worker")&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":Q(r.wasm).then(()=>{ey(r).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})})},e=>{postMessage({type:t,err:e})});break;case"init-ep":{let{epName:e,env:n}=r;ew(n,e).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})});break}case"copy-from":{let{buffer:e}=r,n=ev(e);postMessage({type:t,out:n});break}case"create":{let{model:e,options:n}=r;eE(e,n).then(e=>{postMessage({type:t,out:e})},e=>{postMessage({type:t,err:e})});break}case"release":eT(r),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:n,inputs:o,outputIndices:a,options:i}=r;eC(e,n,o,a,Array(a.length).fill(null),i).then(e=>{e.some(e=>"cpu"!==e[3])?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},eO([...o,...e]))},e=>{postMessage({type:t,err:e})});break}case"end-profiling":eR(r),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),S=N?null:e=>new Worker(e??j,{type:"module",name:"ort-wasm-proxy-worker"})}}),tg=e2({"web/lib/wasm/wasm-utils-import.ts"(){"use strict";th(),M=B||"undefined"==typeof location?void 0:location.origin,k=import.meta.url>"file:"&&import.meta.url<"file;",j=(()=>{if(!B){if(k){let e=URL;return new URL(new e("ort.wasm.mjs",import.meta.url).href,M).href}return import.meta.url}})(),D=()=>{if(j&&!j.startsWith("blob:"))return j.substring(0,j.lastIndexOf("/")+1)},G=(e,t)=>{try{let r=t??j;return(r?new URL(e,r):new URL(e)).origin===M}catch{return!1}},F=async e=>{let t=await fetch(e,{credentials:"same-origin"}),r=await t.blob();return URL.createObjectURL(r)},W=async e=>(await import(e)).default,V=(tw(),e6(ty)).default,H=async()=>{if(!j)throw Error("Failed to load proxy worker: cannot determine the script source URL.");if(G(j))return[void 0,V()];let e=await F(j);return[e,V(e)]},z=void 0,q=async(e,t,r,n)=>{let o=z&&!(e||t);if(o)if(j)o=G(j);else if(n&&!r)o=!0;else throw Error("cannot determine the script source URL.");if(o)return[void 0,z];{let n="ort-wasm-simd-threaded.mjs",o=e??((e,t)=>{let r=t??j;try{return(r?new URL(e,r):new URL(e)).href}catch{return}})(n,t),a=!B&&r&&o&&!G(o,t),i=a?await F(o):o??`${t??"./"}${n}`;return[a?i:void 0,await W(i)]}}}}),tb=e2({"web/lib/wasm/wasm-factory.ts"(){"use strict";tg(),J=!1,Y=!1,K=!1,Q=async e=>{if(J)return Promise.resolve();if(Y)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(K)throw Error("previous call to 'initializeWebAssembly()' failed.");Y=!0;let t=e.initTimeout,r=e.numThreads;if(!1===e.simd);else if("relaxed"===e.simd){if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch(e){return!1}})())throw Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})())throw Error("WebAssembly SIMD is not supported in the current environment.");let n=(()=>{if("undefined"==typeof SharedArrayBuffer)return!1;try{return"undefined"!=typeof MessageChannel&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}})();r>1&&!n&&("undefined"==typeof self||self.crossOriginIsolated||console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let o=e.wasmPaths,a="string"==typeof o?o:void 0,i=o?.mjs,s=i?.href??i,l=o?.wasm,u=l?.href??l,f=e.wasmBinary,[d,p]=await q(s,a,r>1,!!f||!!u),c=!1,m=[];if(t>0&&m.push(new Promise(e=>{setTimeout(()=>{c=!0,e()},t)})),m.push(new Promise((e,t)=>{let n={numThreads:r};if(f)n.wasmBinary=f;else if(u||a)n.locateFile=e=>u??a+e;else if(s&&0!==s.indexOf("blob:"))n.locateFile=e=>new URL(e,s).href;else if(d){let e=D();e&&(n.locateFile=t=>e+t)}p(n).then(t=>{Y=!1,J=!0,Z=t,e(),d&&URL.revokeObjectURL(d)},e=>{Y=!1,K=!0,t(e)})})),await Promise.race(m),c)throw Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},X=()=>{if(J&&Z)return Z;throw Error("WebAssembly is not initialized yet.")}}}),tv=e2({"web/lib/wasm/wasm-utils.ts"(){"use strict";tb(),ee=(e,t)=>{let r=X(),n=r.lengthBytesUTF8(e)+1,o=r._malloc(n);return r.stringToUTF8(e,o,n),t.push(o),o},et=(e,t,r,n)=>{if("object"==typeof e&&null!==e)if(r.has(e))throw Error("Circular reference in options");else r.add(e);Object.entries(e).forEach(([e,o])=>{let a=t?t+e:e;if("object"==typeof o)et(o,a+".",r,n);else if("string"==typeof o||"number"==typeof o)n(a,o.toString());else if("boolean"==typeof o)n(a,o?"1":"0");else throw Error(`Can't handle extra config type: ${typeof o}`)})},er=e=>{let t=X(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);t._OrtGetLastError(n,n+r);let o=Number(t.getValue(n,4===r?"i32":"i64")),a=t.getValue(n+r,"*"),i=a?t.UTF8ToString(a):"";throw Error(`${e} ERROR_CODE: ${o}, ERROR_MESSAGE: ${i}`)}finally{t.stackRestore(r)}}}}),tE=e2({"web/lib/wasm/run-options.ts"(){"use strict";tb(),tv(),en=e=>{let t=X(),r=0,n=[],o=e||{};try{if(e?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw Error(`log severity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(o.terminate=!1);let a=0;return e?.tag!==void 0&&(a=ee(e.tag,n)),r=t._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,a),0===r&&er("Can't create run options."),e?.extra!==void 0&&et(e.extra,"",new WeakSet,(e,o)=>{let a=ee(e,n),i=ee(o,n);0!==t._OrtAddRunConfigEntry(r,a,i)&&er(`Can't set a run config entry: ${e} - ${o}.`)}),[r,n]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),n.forEach(e=>t._free(e)),e}}}}),tT=e2({"web/lib/wasm/session-options.ts"(){"use strict";tb(),tv(),eo=(e,t,r,n)=>{let o=ee(t,n),a=ee(r,n);0!==X()._OrtAddSessionConfigEntry(e,o,a)&&er(`Can't set a session config entry: ${t} - ${r}.`)},ea=async(e,t,r)=>{for(let n of t){let t="string"==typeof n?n:n.name,o=[];switch(t){case"webnn":if(t="WEBNN","string"!=typeof n){let t=n?.deviceType;t&&eo(e,"deviceType",t,r)}break;case"webgpu":if(t="JS","string"!=typeof n&&n?.preferredLayout){if("NCHW"!==n.preferredLayout&&"NHWC"!==n.preferredLayout)throw Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${n.preferredLayout}`);eo(e,"preferredLayout",n.preferredLayout,r)}break;case"wasm":case"cpu":continue;default:throw Error(`not supported execution provider: ${t}`)}let a=ee(t,r),i=o.length,s=0,l=0;if(i>0){s=X()._malloc(i*X().PTR_SIZE),r.push(s),l=X()._malloc(i*X().PTR_SIZE),r.push(l);for(let e=0;e<i;e++)X().setValue(s+e*X().PTR_SIZE,o[e][0],"*"),X().setValue(l+e*X().PTR_SIZE,o[e][1],"*")}await X()._OrtAppendExecutionProvider(e,a,s,l,i)!==0&&er(`Can't append execution provider: ${t}.`)}},ei=async e=>{let t,r=X(),n=0,o=[],a=e||{};a.extra||(a.extra={}),a.extra.session||(a.extra.session={}),(t=a.extra.session).use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),a.executionProviders&&a.executionProviders.some(e=>("string"==typeof e?e:e.name)==="webgpu")&&(a.enableMemPattern=!1);try{let e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${e}`)}})(a.graphOptimizationLevel??"all"),t=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${e}`)}})(a.executionMode??"sequential"),i="string"==typeof a.logId?ee(a.logId,o):0,s=a.logSeverityLevel??2;if(!Number.isInteger(s)||s<0||s>4)throw Error(`log severity level is not valid: ${s}`);let l=a.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw Error(`log verbosity level is not valid: ${l}`);let u="string"==typeof a.optimizedModelFilePath?ee(a.optimizedModelFilePath,o):0;if(n=r._OrtCreateSessionOptions(e,!!a.enableCpuMemArena,!!a.enableMemPattern,t,!!a.enableProfiling,0,i,s,l,u),0===n&&er("Can't create session options."),a.executionProviders&&await ea(n,a.executionProviders,o),void 0!==a.enableGraphCapture){if("boolean"!=typeof a.enableGraphCapture)throw Error(`enableGraphCapture must be a boolean value: ${a.enableGraphCapture}`);eo(n,"enableGraphCapture",a.enableGraphCapture.toString(),o)}if(a.freeDimensionOverrides)for(let[e,t]of Object.entries(a.freeDimensionOverrides)){if("string"!=typeof e)throw Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof t||!Number.isInteger(t)||t<0)throw Error(`free dimension override value must be a non-negative integer: ${t}`);let a=ee(e,o);0!==r._OrtAddFreeDimensionOverride(n,a,t)&&er(`Can't set a free dimension override: ${e} - ${t}.`)}return void 0!==a.extra&&et(a.extra,"",new WeakSet,(e,t)=>{eo(n,e,t,o)}),[n,o]}catch(e){throw 0!==n&&0!==r._OrtReleaseSessionOptions(n)&&er("Can't release session options."),o.forEach(e=>r._free(e)),e}}}}),tA=e2({"web/lib/wasm/wasm-common.ts"(){"use strict";es=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw Error(`unsupported data type: ${e}`)}},el=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw Error(`unsupported data type: ${e}`)}},eu=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n="number"==typeof t?t:t.reduce((e,t)=>e*t,1);return r>0?Math.ceil(n*r):void 0},ef=e=>{switch(e){case"float16":return"undefined"!=typeof Float16Array&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${e}`)}},ed=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${e}`)}},ep=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,ec=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,em=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw Error(`unsupported data location: ${e}`)}}}}),tC=e2({"web/lib/wasm/wasm-utils-load-file.ts"(){"use strict";th(),eh=async e=>{if("string"==typeof e)if(B)try{let{readFile:t}=e1("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if("ERR_FS_FILE_TOO_LARGE"===t.code){let{createReadStream:t}=e1("node:fs"),r=t(e),n=[];for await(let e of r)n.push(e);return new Uint8Array(Buffer.concat(n))}throw t}else{let t=await fetch(e);if(!t.ok)throw Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),n=r?parseInt(r,10):0;if(n<0x40000000)return new Uint8Array(await t.arrayBuffer());{let r;if(!t.body)throw Error(`failed to load external data file: ${e}, no response body.`);let o=t.body.getReader();try{r=new ArrayBuffer(n)}catch(e){if(e instanceof RangeError){let e=Math.ceil(n/65536);r=new WebAssembly.Memory({initial:e,maximum:e}).buffer}else throw e}let a=0;for(;;){let{done:e,value:t}=await o.read();if(e)break;let n=t.byteLength;new Uint8Array(r,a,n).set(t),a+=n}return new Uint8Array(r,0,n)}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}}),tR=e2({"web/lib/wasm/wasm-core-impl.ts"(){"use strict";tm(),tE(),tT(),tA(),tb(),tv(),tC(),ey=async e=>{var t,r;t=e.wasm.numThreads,r=ed(e.logLevel),0!==X()._OrtInit(t,r)&&er("Can't initialize onnxruntime.")},ew=async(e,t)=>{X().asyncInit?.();let r=e.webgpu.adapter;if("webgpu"===t){if("undefined"==typeof navigator||!navigator.gpu)throw Error("WebGPU is not supported in current environment");if(r){if("object"!=typeof r.limits||"object"!=typeof r.features||"function"!=typeof r.requestDevice)throw Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let t=e.webgpu.powerPreference;if(void 0!==t&&"low-power"!==t&&"high-performance"!==t)throw Error(`Invalid powerPreference setting: "${t}"`);let n=e.webgpu.forceFallbackAdapter;if(void 0!==n&&"boolean"!=typeof n)throw Error(`Invalid forceFallbackAdapter setting: "${n}"`);if(!(r=await navigator.gpu.requestAdapter({powerPreference:t,forceFallbackAdapter:n})))throw Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if("webnn"===t&&("undefined"==typeof navigator||!navigator.ml))throw Error("WebNN is not supported in current environment")},eg=new Map,eb=(e,t)=>{let r=X(),n=r.stackSave(),o=0;try{let n=r.PTR_SIZE,a=r.stackAlloc(2*n),i=r._OrtGetInputOutputMetadata(e,t,a,a+n);0!==i&&er("Can't get session input/output metadata.");let s=Number(r.getValue(a,"*"));o=Number(r.getValue(a+n,"*"));let l=r.HEAP32[o/4];if(0===l)return[s,0];let u=r.HEAPU32[o/4+1],f=[];for(let e=0;e<u;e++){let t=Number(r.getValue(o+8+e*n,"*"));f.push(0!==t?r.UTF8ToString(t):Number(r.getValue(o+8+(e+u)*n,"*")))}return[s,l,f]}finally{r.stackRestore(n),0!==o&&r._OrtFree(o)}},ev=e=>{let t=X(),r=t._malloc(e.byteLength);if(0===r)throw Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},eE=async(e,t)=>{let r,n,o=X();Array.isArray(e)?[r,n]=e:e.buffer===o.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=ev(e);let a=0,i=0,s=[],l=[],u=[];try{if([i,s]=await ei(t),t?.externalData&&o.mountExternalData){let e=[];for(let r of t.externalData){let t="string"==typeof r?r:r.path;e.push(eh("string"==typeof r?r:r.data).then(e=>{o.mountExternalData(t,e)}))}await Promise.all(e)}for(let e of t?.executionProviders??[]){let t="string"==typeof e?e:e.name;if("webnn"===t){if(o.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e?.context,r=e?.gpuDevice,n=e?.deviceType,a=e?.powerPreference;t?o.currentContext=t:r?o.currentContext=await o.webnnCreateMLContext(r):o.currentContext=await o.webnnCreateMLContext({deviceType:n,powerPreference:a})}else o.currentContext=await o.webnnCreateMLContext();break}}a=await o._OrtCreateSession(r,n,i),o.webgpuOnCreateSession?.(a),0===a&&er("Can't create a session."),o.jsepOnCreateSession?.(),o.currentContext&&(o.webnnRegisterMLContext(a,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[e,f]=(e=>{let t=X(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r),o=t._OrtGetInputOutputCount(e,n,n+r);0!==o&&er("Can't get session input/output count.");let a=4===r?"i32":"i64";return[Number(t.getValue(n,a)),Number(t.getValue(n+r,a))]}finally{t.stackRestore(r)}})(a),d=!!t?.enableGraphCapture,p=[],c=[],m=[],h=[];for(let t=0;t<e;t++){let[e,r,n]=eb(a,t);0===e&&er("Can't get an input name."),l.push(e);let i=o.UTF8ToString(e);p.push(i),m.push(0===r?{name:i,isTensor:!1}:{name:i,isTensor:!0,type:el(r),shape:n})}for(let t=0;t<f;t++){let[r,n,i]=eb(a,t+e);0===r&&er("Can't get an output name."),u.push(r);let s=o.UTF8ToString(r);c.push(s),h.push(0===n?{name:s,isTensor:!1}:{name:s,isTensor:!0,type:el(n),shape:i})}return eg.set(a,[a,l,u,null,d,!1]),[a,p,c,m,h]}catch(e){throw l.forEach(e=>o._OrtFree(e)),u.forEach(e=>o._OrtFree(e)),0!==a&&0!==o._OrtReleaseSession(a)&&er("Can't release session."),e}finally{o._free(r),0!==i&&0!==o._OrtReleaseSessionOptions(i)&&er("Can't release session options."),s.forEach(e=>o._free(e)),o.unmountExternalData?.()}},eT=e=>{let t=X(),r=eg.get(e);if(!r)throw Error(`cannot release session. invalid session id: ${e}`);let[n,o,a,i,s]=r;i&&(s&&0!==t._OrtClearBoundOutputs(i.handle)&&er("Can't clear bound outputs."),0!==t._OrtReleaseBinding(i.handle)&&er("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),o.forEach(e=>t._OrtFree(e)),a.forEach(e=>t._OrtFree(e)),0!==t._OrtReleaseSession(n)&&er("Can't release session."),eg.delete(e)},eA=async(e,t,r,n,o,a,i=!1)=>{let s,l;if(!e)return void t.push(0);let u=X(),f=u.PTR_SIZE,d=e[0],p=e[1],c=e[3],m=c;if("string"===d&&("gpu-buffer"===c||"ml-tensor"===c))throw Error("String tensor is not supported on GPU.");if(i&&"gpu-buffer"!==c)throw Error(`External buffer must be provided for input/output index ${a} when enableGraphCapture is true.`);if("gpu-buffer"===c){let t=e[2].gpuBuffer;l=eu(es(d),p);{let e=u.jsepRegisterBuffer;if(!e)throw Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');s=e(n,a,t,l)}}else if("ml-tensor"===c){let t=e[2].mlTensor;l=eu(es(d),p);let r=u.webnnRegisterMLTensor;if(!r)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');s=r(n,t,es(d),p)}else{let t=e[2];if(Array.isArray(t)){l=f*t.length,s=u._malloc(l),r.push(s);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw TypeError(`tensor data at index ${e} is not a string`);u.setValue(s+e*f,ee(t[e],r),"*")}}else{let e=u.webnnIsGraphInput,a=u.webnnIsGraphOutput;if("string"!==d&&e&&a){let i=u.UTF8ToString(o);if(e(n,i)||a(n,i)){let e=es(d);l=eu(e,p),m="ml-tensor";let r=u.webnnCreateTemporaryTensor,o=u.webnnUploadTensor;if(!r||!o)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');let a=await r(n,e,p);o(a,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),s=a}else l=t.byteLength,s=u._malloc(l),r.push(s),u.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,l),s)}else l=t.byteLength,s=u._malloc(l),r.push(s),u.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,l),s)}}let h=u.stackSave(),y=u.stackAlloc(4*p.length);try{p.forEach((e,t)=>u.setValue(y+t*f,e,4===f?"i32":"i64"));let e=u._OrtCreateTensor(es(d),s,l,y,p.length,em(m));0===e&&er(`Can't create tensor for input/output. session=${n}, index=${a}.`),t.push(e)}finally{u.stackRestore(h)}},eC=async(e,t,r,n,o,a)=>{let i=X(),s=i.PTR_SIZE,l=eg.get(e);if(!l)throw Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],f=l[1],d=l[2],p=l[3],c=l[4];l[5];let m=t.length,h=n.length,y=0,w=[],g=[],b=[],v=[],E=i.stackSave(),T=i.stackAlloc(m*s),A=i.stackAlloc(m*s),C=i.stackAlloc(h*s),R=i.stackAlloc(h*s);try{let l;[y,w]=en(a),I("wasm prepareInputOutputTensor");for(let n=0;n<m;n++)await eA(r[n],g,v,e,f[t[n]],t[n],c);for(let t=0;t<h;t++)await eA(o[t],b,v,e,d[n[t]],m+n[t],c);P("wasm prepareInputOutputTensor");for(let e=0;e<m;e++)i.setValue(T+e*s,g[e],"*"),i.setValue(A+e*s,f[t[e]],"*");for(let e=0;e<h;e++)i.setValue(C+e*s,b[e],"*"),i.setValue(R+e*s,d[n[e]],"*");i.jsepOnRunStart?.(u),i.webnnOnRunStart?.(u),l=await i._OrtRun(u,A,T,m,R,h,C,y),0!==l&&er("failed to call OrtRun().");let E=[],O=[];I("wasm ProcessOutputTensor");for(let t=0;t<h;t++){let r=Number(i.getValue(C+t*s,"*"));if(r===b[t]){E.push(o[t]);continue}let a=i.stackSave(),l=i.stackAlloc(4*s),u=!1,f,d=0;try{let o=i._OrtGetTensorData(r,l,l+s,l+2*s,l+3*s);0!==o&&er(`Can't access output tensor data on index ${t}.`);let a=4===s?"i32":"i64",c=Number(i.getValue(l,a));d=i.getValue(l+s,"*");let m=i.getValue(l+2*s,"*"),h=Number(i.getValue(l+3*s,a)),y=[];for(let e=0;e<h;e++)y.push(Number(i.getValue(m+e*s,a)));0!==i._OrtFree(m)&&er("Can't free memory for tensor dims.");let w=y.reduce((e,t)=>e*t,1);f=el(c);let g=p?.outputPreferredLocations[n[t]];if("string"===f){if("gpu-buffer"===g||"ml-tensor"===g)throw Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<w;t++){let r=i.getValue(d+t*s,"*"),n=i.getValue(d+(t+1)*s,"*"),o=t===w-1?void 0:n-r;e.push(i.UTF8ToString(r,o))}E.push([f,y,e,"cpu"])}else if("gpu-buffer"===g&&w>0){let e=i.jsepGetBuffer;if(!e)throw Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let t=e(d),n=eu(c,w);if(void 0===n||!ep(f))throw Error(`Unsupported data type: ${f}`);u=!0,E.push([f,y,{gpuBuffer:t,download:i.jsepCreateDownloader(t,n,f),dispose:()=>{0!==i._OrtReleaseTensor(r)&&er("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===g&&w>0){let t=i.webnnEnsureTensor,n=i.webnnIsGraphInputOutputTypeSupported;if(!t||!n)throw Error('preferredLocation "ml-tensor" is not supported without using WebNN.');let o=eu(c,w);if(void 0===o||!ec(f))throw Error(`Unsupported data type: ${f}`);if(!n(e,f,!1))throw Error(`preferredLocation "ml-tensor" for ${f} output is not supported by current WebNN Context.`);let a=await t(e,d,c,y,!1);u=!0,E.push([f,y,{mlTensor:a,download:i.webnnCreateMLTensorDownloader(d,f),dispose:()=>{i.webnnReleaseTensorId(d),i._OrtReleaseTensor(r)}},"ml-tensor"])}else if("ml-tensor-cpu-output"===g&&w>0){let e=i.webnnCreateMLTensorDownloader(d,f)(),t=E.length;u=!0,O.push((async()=>{let n=[t,await e];return i.webnnReleaseTensorId(d),i._OrtReleaseTensor(r),n})()),E.push([f,y,[],"cpu"])}else{let e=new(ef(f))(w);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(i.HEAPU8.subarray(d,d+e.byteLength)),E.push([f,y,e,"cpu"])}}finally{i.stackRestore(a),"string"===f&&d&&i._free(d),u||i._OrtReleaseTensor(r)}}for(let[t,r]of(p&&!c&&(0!==i._OrtClearBoundOutputs(p.handle)&&er("Can't clear bound outputs."),eg.set(e,[u,f,d,p,c,!1])),await Promise.all(O)))E[t][2]=r;return P("wasm ProcessOutputTensor"),E}finally{i.webnnOnRunEnd?.(u),i.stackRestore(E),g.forEach(e=>i._OrtReleaseTensor(e)),b.forEach(e=>i._OrtReleaseTensor(e)),v.forEach(e=>i._free(e)),0!==y&&i._OrtReleaseRunOptions(y),w.forEach(e=>i._free(e))}},eR=e=>{let t=X(),r=eg.get(e);if(!r)throw Error("invalid session id");let n=r[0],o=t._OrtEndProfiling(n);0===o&&er("Can't get an profile file name."),t._OrtFree(o)},eO=e=>{let t=[];for(let r of e){let e=r[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}}}),tO=e2({"web/lib/wasm/proxy-wrapper.ts"(){"use strict";tm(),tR(),tb(),tg(),eU=()=>!!u.wasm.proxy&&"undefined"!=typeof document,eL=!1,eI=!1,eP=!1,eB=new Map,eN=(e,t)=>{let r=eB.get(e);r?r.push(t):eB.set(e,[t])},eS=()=>{if(eL||!eI||eP||!ex)throw Error("worker not ready")},eM=e=>{switch(e.data.type){case"init-wasm":eL=!1,e.data.err?(eP=!0,e_[1](e.data.err)):(eI=!0,e_[0]()),e$&&(URL.revokeObjectURL(e$),e$=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=eB.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out)}}},ek=async()=>{if(!eI){if(eL)throw Error("multiple calls to 'initWasm()' detected.");if(eP)throw Error("previous call to 'initWasm()' failed.");if(eL=!0,eU())return new Promise((e,t)=>{ex?.terminate(),H().then(([r,n])=>{try{(ex=n).onerror=e=>t(e),ex.onmessage=eM,e_=[e,t];let o={type:"init-wasm",in:u};if(!o.in.wasm.wasmPaths&&r){let e=D();e&&(o.in.wasm.wasmPaths=e)}ex.postMessage(o),e$=r}catch(e){t(e)}},t)});try{await Q(u.wasm),await ey(u),eI=!0}catch(e){throw eP=!0,e}finally{eL=!1}}},ej=async e=>{if(eU())return eS(),new Promise((t,r)=>{eN("init-ep",[t,r]);let n={type:"init-ep",in:{epName:e,env:u}};ex.postMessage(n)});await ew(u,e)},eD=async e=>eU()?(eS(),new Promise((t,r)=>{eN("copy-from",[t,r]),ex.postMessage({type:"copy-from",in:{buffer:e}},[e.buffer])})):ev(e),eG=async(e,t)=>{if(!eU())return eE(e,t);if(t?.preferredOutputLocation)throw Error('session option "preferredOutputLocation" is not supported for proxy.');return eS(),new Promise((r,n)=>{eN("create",[r,n]);let o={type:"create",in:{model:e,options:{...t}}},a=[];e instanceof Uint8Array&&a.push(e.buffer),ex.postMessage(o,a)})},eF=async e=>{if(eU())return eS(),new Promise((t,r)=>{eN("release",[t,r]),ex.postMessage({type:"release",in:e})});eT(e)},eW=async(e,t,r,n,o,a)=>{if(!eU())return eC(e,t,r,n,o,a);if(r.some(e=>"cpu"!==e[3]))throw Error("input tensor on GPU is not supported for proxy.");if(o.some(e=>e))throw Error("pre-allocated output tensor is not supported for proxy.");return eS(),new Promise((o,i)=>{eN("run",[o,i]),ex.postMessage({type:"run",in:{sessionId:e,inputIndices:t,inputs:r,outputIndices:n,options:a}},eO(r))})},eV=async e=>{if(eU())return eS(),new Promise((t,r)=>{eN("end-profiling",[t,r]),ex.postMessage({type:"end-profiling",in:e})});eR(e)}}}),tU=e2({"web/lib/wasm/session-handler-inference.ts"(){"use strict";tm(),tO(),tA(),th(),tC(),eH=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw Error(`invalid data location: ${e.location} for ${t()}`)}},ez=e=>{switch(e[3]){case"cpu":return new R(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!ep(t))throw Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:o}=e[2];return R.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:o})}case"ml-tensor":{let t=e[0];if(!ec(t))throw Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:o}=e[2];return R.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:o})}default:throw Error(`invalid data location: ${e[3]}`)}},eq=class{async fetchModelAndCopyToWasmMemory(e){return eD(await eh(e))}async loadModel(e,t){let r;x(),r="string"==typeof e?B?await eh(e):await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await eG(r,t),L()}async dispose(){return eF(this.sessionId)}async run(e,t,r){x();let n=[],o=[];Object.entries(e).forEach(e=>{let t=e[0],r=e[1],a=this.inputNames.indexOf(t);if(-1===a)throw Error(`invalid input '${t}'`);n.push(r),o.push(a)});let a=[],i=[];Object.entries(t).forEach(e=>{let t=e[0],r=e[1],n=this.outputNames.indexOf(t);if(-1===n)throw Error(`invalid output '${t}'`);a.push(r),i.push(n)});let s=n.map((e,t)=>eH(e,()=>`input "${this.inputNames[o[t]]}"`)),l=a.map((e,t)=>e?eH(e,()=>`output "${this.outputNames[i[t]]}"`):null),u=await eW(this.sessionId,o,s,i,l,r),f={};for(let e=0;e<u.length;e++)f[this.outputNames[i[e]]]=a[e]??ez(u[e]);return L(),f}startProfiling(){}endProfiling(){eV(this.sessionId)}}}}),tx={};e3(tx,{OnnxruntimeWebAssemblyBackend:()=>eJ,initializeFlags:()=>eZ,wasmBackend:()=>eY});var tL=e2({"web/lib/backend-wasm.ts"(){"use strict";tm(),tO(),tU(),eZ=()=>{("number"!=typeof u.wasm.initTimeout||u.wasm.initTimeout<0)&&(u.wasm.initTimeout=0);let e=u.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),u.wasm.simd=!1),"boolean"!=typeof u.wasm.proxy&&(u.wasm.proxy=!1),"boolean"!=typeof u.wasm.trace&&(u.wasm.trace=!1),"number"!=typeof u.wasm.numThreads||!Number.isInteger(u.wasm.numThreads)||u.wasm.numThreads<=0)if("undefined"==typeof self||self.crossOriginIsolated){let e="undefined"==typeof navigator?e1("node:os").cpus().length:navigator.hardwareConcurrency;u.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}else u.wasm.numThreads=1},eY=new(eJ=class{async init(e){eZ(),await ek(),await ej(e)}async createInferenceSessionHandler(e,t){let r=new eq;return await r.loadModel(e,t),r}})}});tm(),tm(),tm();var tI=tc;{let e=(tL(),e6(tx)).wasmBackend;n("cpu",e,10),n("wasm",e,10)}Object.defineProperty(u.versions,"web",{value:"1.23.2",enumerable:!0});export{_ as InferenceSession,O as TRACE,I as TRACE_EVENT_BEGIN,P as TRACE_EVENT_END,x as TRACE_FUNC_BEGIN,L as TRACE_FUNC_END,R as Tensor,tI as default,u as env,n as registerBackend};