/*! For license information please see ort.wasm.min.mjs.LICENSE.txt */
let t;var r=Object.defineProperty,n=Object.getOwnPropertyDescriptor,a=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,i,s,u,l,f,p,d,c,h,m,y,g,w,b,v,E,T,A,C,R,O,U,I,L,x,P,$,_,B,N,M,S,k,D=(t=function(t){if("u">typeof require)return require.apply(this,arguments);throw Error('Dynamic require of "'+t+'" is not supported')},"u">typeof require?require:"u">typeof Proxy?new Proxy(t,{get:(t,r)=>("u">typeof require?require:t)[r]}):t),G=(t,r)=>()=>(t&&(r=t(t=0)),r),F=(t,n)=>{for(var a in n)r(t,a,{get:n[a],enumerable:!0})},j=t=>((t,i,s,u)=>{if(i&&"object"==typeof i||"function"==typeof i)for(let l of a(i))o.call(t,l)||l===s||r(t,l,{get:()=>i[l],enumerable:!(u=n(i,l))||u.enumerable});return t})(r({},"__esModule",{value:!0}),t),W=G(()=>{"use strict";i=new Map,s=[],u=(t,r,n)=>{if(r&&"function"==typeof r.init&&"function"==typeof r.createInferenceSessionHandler){let a=i.get(t);if(void 0===a)i.set(t,{backend:r,priority:n});else{if(a.priority>n)return;if(a.priority===n&&a.backend!==r)throw Error(`cannot register backend "${t}" using priority ${n}`)}if(n>=0){let r=s.indexOf(t);-1!==r&&s.splice(r,1);for(let r=0;r<s.length;r++)if(i.get(s[r]).priority<=n)return void s.splice(r,0,t);s.push(t)}return}throw TypeError("not a valid backend")},l=async t=>{let r=i.get(t);if(!r)return"backend not found.";if(r.initialized)return r.backend;if(r.aborted)return r.error;{let n=!!r.initPromise;try{return n||(r.initPromise=r.backend.init(t)),await r.initPromise,r.initialized=!0,r.backend}catch(t){return n||(r.error=`${t}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},f=async t=>{let r=t.executionProviders||[],n=r.map(t=>"string"==typeof t?t:t.name),a=0===n.length?s:n,o,i=[],u=new Set;for(let t of a){let r=await l(t);"string"==typeof r?i.push({name:t,err:r}):(o||(o=r),o===r&&u.add(t))}if(!o)throw Error(`no available backend found. ERR: ${i.map(t=>`[${t.name}] ${t.err}`).join(", ")}`);for(let{name:t,err:r}of i)n.includes(t)&&console.warn(`removing requested execution provider "${t}" from session options because it is not available: ${r}`);let f=r.filter(t=>u.has("string"==typeof t?t:t.name));return[o,new Proxy(t,{get:(t,r)=>"executionProviders"===r?f:Reflect.get(t,r)})]}}),V=G(()=>{"use strict";W()}),H=G(()=>{"use strict";p="1.23.2"}),z=G(()=>{"use strict";H(),d="warning",Object.defineProperty(c={wasm:{},webgl:{},webgpu:{},versions:{common:p},set logLevel(e){if(void 0!==e){if("string"!=typeof e||-1===["verbose","info","warning","error","fatal"].indexOf(e))throw Error(`Unsupported logging level: ${e}`);d=e}},get logLevel(){return d}},"logLevel",{enumerable:!0})}),q=G(()=>{"use strict";z(),h=c}),Z=G(()=>{"use strict";m=(t,r)=>{let n="u">typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);n.width=t.dims[3],n.height=t.dims[2];let a=n.getContext("2d");if(null!=a){let o,i;r?.tensorLayout!==void 0&&"NHWC"===r.tensorLayout?(o=t.dims[2],i=t.dims[3]):(o=t.dims[3],i=t.dims[2]);let s=r?.format!==void 0?r.format:"RGB",u=r?.norm,l,f;void 0===u||void 0===u.mean?l=[255,255,255,255]:"number"==typeof u.mean?l=[u.mean,u.mean,u.mean,u.mean]:(l=[u.mean[0],u.mean[1],u.mean[2],0],void 0!==u.mean[3]&&(l[3]=u.mean[3])),void 0===u||void 0===u.bias?f=[0,0,0,0]:"number"==typeof u.bias?f=[u.bias,u.bias,u.bias,u.bias]:(f=[u.bias[0],u.bias[1],u.bias[2],0],void 0!==u.bias[3]&&(f[3]=u.bias[3]));let p=i*o,d=0,c=p,h=2*p,m=-1;"RGBA"===s?(d=0,c=p,h=2*p,m=3*p):"RGB"===s?(d=0,c=p,h=2*p):"RBG"===s&&(d=0,h=p,c=2*p);for(let r=0;r<i;r++)for(let n=0;n<o;n++)a.fillStyle="rgba("+(t.data[d++]-f[0])*l[0]+","+(t.data[c++]-f[1])*l[1]+","+(t.data[h++]-f[2])*l[2]+","+(-1===m?255:(t.data[m++]-f[3])*l[3])+")",a.fillRect(n,r,1,1);if("toDataURL"in n)return n.toDataURL();throw Error("toDataURL is not supported")}throw Error("Can not access image data")},y=(t,r)=>{let n="u">typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),a;if(null!=n){let o,i,s;r?.tensorLayout!==void 0&&"NHWC"===r.tensorLayout?(o=t.dims[2],i=t.dims[1],s=t.dims[3]):(o=t.dims[3],i=t.dims[2],s=t.dims[1]);let u=void 0!==r&&void 0!==r.format?r.format:"RGB",l=r?.norm,f,p;void 0===l||void 0===l.mean?f=[255,255,255,255]:"number"==typeof l.mean?f=[l.mean,l.mean,l.mean,l.mean]:(f=[l.mean[0],l.mean[1],l.mean[2],255],void 0!==l.mean[3]&&(f[3]=l.mean[3])),void 0===l||void 0===l.bias?p=[0,0,0,0]:"number"==typeof l.bias?p=[l.bias,l.bias,l.bias,l.bias]:(p=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(p[3]=l.bias[3]));let d=i*o;if(void 0!==r&&(void 0!==r.format&&4===s&&"RGBA"!==r.format||3===s&&"RGB"!==r.format&&"BGR"!==r.format))throw Error("Tensor format doesn't match input tensor dims");let c=0,h=1,m=2,y=3,g=0,w=d,b=2*d,v=-1;"RGBA"===u?(g=0,w=d,b=2*d,v=3*d):"RGB"===u?(g=0,w=d,b=2*d):"RBG"===u&&(g=0,b=d,w=2*d),a=n.createImageData(o,i);for(let r=0;r<i*o;c+=4,h+=4,m+=4,y+=4,r++)a.data[c]=(t.data[g++]-p[0])*f[0],a.data[h]=(t.data[w++]-p[1])*f[1],a.data[m]=(t.data[b++]-p[2])*f[2],a.data[y]=-1===v?255:(t.data[v++]-p[3])*f[3]}else throw Error("Can not access image data");return a}}),J=G(()=>{"use strict";X(),g=(t,r)=>{if(void 0===t)throw Error("Image buffer must be defined");if(void 0===r.height||void 0===r.width)throw Error("Image height and width must be defined");if("NHWC"===r.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:n,width:a}=r,o=r.norm??{mean:255,bias:0},i,s;i="number"==typeof o.mean?[o.mean,o.mean,o.mean,o.mean]:[o.mean[0],o.mean[1],o.mean[2],o.mean[3]??255],s="number"==typeof o.bias?[o.bias,o.bias,o.bias,o.bias]:[o.bias[0],o.bias[1],o.bias[2],o.bias[3]??0];let u=void 0!==r.format?r.format:"RGBA",l=void 0!==r.tensorFormat&&void 0!==r.tensorFormat?r.tensorFormat:"RGB",f=n*a,p=new Float32Array("RGBA"===l?4*f:3*f),d=4,c=0,h=1,m=2,y=3,g=0,w=f,b=2*f,v=-1;"RGB"===u&&(d=3,c=0,h=1,m=2,y=-1),"RGBA"===l?v=3*f:"RBG"===l?(g=0,b=f,w=2*f):"BGR"===l&&(b=0,w=f,g=2*f);for(let r=0;r<f;r++,c+=d,m+=d,h+=d,y+=d)p[g++]=(t[c]+s[0])/i[0],p[w++]=(t[h]+s[1])/i[1],p[b++]=(t[m]+s[2])/i[2],-1!==v&&-1!==y&&(p[v++]=(t[y]+s[3])/i[3]);return"RGBA"===l?new L("float32",p,[1,4,n,a]):new L("float32",p,[1,3,n,a])},w=async(t,r)=>{let n="u">typeof HTMLImageElement&&t instanceof HTMLImageElement,a="u">typeof ImageData&&t instanceof ImageData,o="u">typeof ImageBitmap&&t instanceof ImageBitmap,i="string"==typeof t,s,u=r??{},l=()=>{if("u">typeof document)return document.createElement("canvas");if("u">typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},f=t=>"u">typeof HTMLCanvasElement&&t instanceof HTMLCanvasElement||t instanceof OffscreenCanvas?t.getContext("2d"):null;if(n){let n=l();n.width=t.width,n.height=t.height;let a=f(n);if(null!=a){let n=t.height,o=t.width;if(void 0!==r&&void 0!==r.resizedHeight&&void 0!==r.resizedWidth&&(n=r.resizedHeight,o=r.resizedWidth),void 0!==r){if(u=r,void 0!==r.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");u.tensorFormat="RGBA",u.height=n,u.width=o}else u.tensorFormat="RGBA",u.height=n,u.width=o;a.drawImage(t,0,0),s=a.getImageData(0,0,o,n).data}else throw Error("Can not access image data")}else if(a){let n,a;if(void 0!==r&&void 0!==r.resizedWidth&&void 0!==r.resizedHeight?(n=r.resizedHeight,a=r.resizedWidth):(n=t.height,a=t.width),void 0!==r&&(u=r),u.format="RGBA",u.height=n,u.width=a,void 0!==r){let r=l();r.width=a,r.height=n;let o=f(r);if(null!=o)o.putImageData(t,0,0),s=o.getImageData(0,0,a,n).data;else throw Error("Can not access image data")}else s=t.data}else if(o){if(void 0===r)throw Error("Please provide image config with format for Imagebitmap");let n=l();n.width=t.width,n.height=t.height;let a=f(n);if(null!=a){let r=t.height,n=t.width;return a.drawImage(t,0,0,n,r),s=a.getImageData(0,0,n,r).data,u.height=r,u.width=n,g(s,u)}throw Error("Can not access image data")}else{if(i)return new Promise((r,n)=>{let a=l(),o=f(a);if(!t||!o)return n();let i=new Image;i.crossOrigin="Anonymous",i.src=t,i.onload=()=>{a.width=i.width,a.height=i.height,o.drawImage(i,0,0,a.width,a.height);let t=o.getImageData(0,0,a.width,a.height);u.height=a.height,u.width=a.width,r(g(t.data,u))}});throw Error("Input data provided is not supported - aborted tensor creation")}if(void 0!==s)return g(s,u);throw Error("Input data provided is not supported - aborted tensor creation")},b=(t,r)=>{let{width:n,height:a,download:o,dispose:i}=r;return new L({location:"texture",type:"float32",texture:t,dims:[1,a,n,4],download:o,dispose:i})},v=(t,r)=>{let{dataType:n,dims:a,download:o,dispose:i}=r;return new L({location:"gpu-buffer",type:n??"float32",gpuBuffer:t,dims:a,download:o,dispose:i})},E=(t,r)=>{let{dataType:n,dims:a,download:o,dispose:i}=r;return new L({location:"ml-tensor",type:n??"float32",mlTensor:t,dims:a,download:o,dispose:i})},T=(t,r,n)=>new L({location:"cpu-pinned",type:t,data:r,dims:n??[r.length]})}),K=G(()=>{"use strict";A=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),C=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),R=!1,O=()=>{if(!R){R=!0;let t="u">typeof BigInt64Array&&BigInt64Array.from,r="u">typeof BigUint64Array&&BigUint64Array.from,n=globalThis.Float16Array,a="u">typeof n&&n.from;t&&(A.set("int64",BigInt64Array),C.set(BigInt64Array,"int64")),r&&(A.set("uint64",BigUint64Array),C.set(BigUint64Array,"uint64")),a?(A.set("float16",n),C.set(n,"float16")):A.set("float16",Uint16Array)}}}),Q=G(()=>{"use strict";X(),U=t=>{let r=1;for(let n=0;n<t.length;n++){let a=t[n];if("number"!=typeof a||!Number.isSafeInteger(a))throw TypeError(`dims[${n}] must be an integer, got: ${a}`);if(a<0)throw RangeError(`dims[${n}] must be a non-negative integer, got: ${a}`);r*=a}return r},I=(t,r)=>{switch(t.location){case"cpu":return new L(t.type,t.data,r);case"cpu-pinned":return new L({location:"cpu-pinned",data:t.data,type:t.type,dims:r});case"texture":return new L({location:"texture",texture:t.texture,type:t.type,dims:r});case"gpu-buffer":return new L({location:"gpu-buffer",gpuBuffer:t.gpuBuffer,type:t.type,dims:r});case"ml-tensor":return new L({location:"ml-tensor",mlTensor:t.mlTensor,type:t.type,dims:r});default:throw Error(`tensorReshape: tensor location ${t.location} is not supported`)}}}),X=G(()=>{"use strict";Z(),J(),K(),Q(),L=class{constructor(t,r,n){let a,o;if(O(),"object"==typeof t&&"location"in t)switch(this.dataLocation=t.location,a=t.type,o=t.dims,t.location){case"cpu-pinned":{let r=A.get(a);if(!r)throw TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(t.data instanceof r))throw TypeError(`buffer should be of type ${r.name}`);this.cpuData=t.data;break}case"texture":if("float32"!==a)throw TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=t.texture,this.downloader=t.download,this.disposer=t.dispose;break;case"gpu-buffer":if("float32"!==a&&"float16"!==a&&"int32"!==a&&"int64"!==a&&"uint32"!==a&&"uint8"!==a&&"bool"!==a&&"uint4"!==a&&"int4"!==a)throw TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=t.gpuBuffer,this.downloader=t.download,this.disposer=t.dispose;break;case"ml-tensor":if("float32"!==a&&"float16"!==a&&"int32"!==a&&"int64"!==a&&"uint32"!==a&&"uint64"!==a&&"int8"!==a&&"uint8"!==a&&"bool"!==a&&"uint4"!==a&&"int4"!==a)throw TypeError(`unsupported type "${a}" to create tensor from MLTensor`);this.mlTensorData=t.mlTensor,this.downloader=t.download,this.disposer=t.dispose;break;default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let i,s;if("string"==typeof t)if(a=t,s=n,"string"===t){if(!Array.isArray(r))throw TypeError("A string tensor's data must be a string array.");i=r}else{let n=A.get(t);if(void 0===n)throw TypeError(`Unsupported tensor type: ${t}.`);if(Array.isArray(r)){if("float16"===t&&n===Uint16Array||"uint4"===t||"int4"===t)throw TypeError(`Creating a ${t} tensor from number array is not supported. Please use ${n.name} as data.`);i="uint64"===t||"int64"===t?n.from(r,BigInt):n.from(r)}else if(r instanceof n)i=r;else if(r instanceof Uint8ClampedArray)if("uint8"===t)i=Uint8Array.from(r);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if("float16"===t&&r instanceof Uint16Array&&n!==Uint16Array)i=new globalThis.Float16Array(r.buffer,r.byteOffset,r.length);else throw TypeError(`A ${a} tensor's data must be type of ${n}`)}else if(s=r,Array.isArray(t)){if(0===t.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let r=typeof t[0];if("string"===r)a="string",i=t;else if("boolean"===r)a="bool",i=Uint8Array.from(t);else throw TypeError(`Invalid element type of data array: ${r}.`)}else if(t instanceof Uint8ClampedArray)a="uint8",i=Uint8Array.from(t);else{let r=C.get(t.constructor);if(void 0===r)throw TypeError(`Unsupported type for tensor data: ${t.constructor}.`);a=r,i=t}if(void 0===s)s=[i.length];else if(!Array.isArray(s))throw TypeError("A tensor's dims must be a number array");o=s,this.cpuData=i,this.dataLocation="cpu"}let i=U(o);if(this.cpuData&&i!==this.cpuData.length&&("uint4"!==a&&"int4"!==a||Math.ceil(i/2)!==this.cpuData.length))throw Error(`Tensor's size(${i}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=o,this.size=i}static async fromImage(t,r){return w(t,r)}static fromTexture(t,r){return b(t,r)}static fromGpuBuffer(t,r){return v(t,r)}static fromMLTensor(t,r){return E(t,r)}static fromPinnedBuffer(t,r,n){return T(t,r,n)}toDataURL(t){return m(this,t)}toImageData(t){return y(this,t)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(t){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let r=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=r,t&&this.disposer&&(this.disposer(),this.disposer=void 0),r}finally{this.isDownloading=!1}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw Error("The tensor is disposed.")}reshape(t){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");return I(this,t)}}}),Y=G(()=>{"use strict";X(),x=L}),ee=G(()=>{"use strict";z(),P=(t,r)=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&console.timeStamp(`${t}::ORT::${r}`)},$=(t,r)=>{let n=Error().stack?.split(/\r\n|\r|\n/g)||[],a=!1;for(let o=0;o<n.length;o++){if(a&&!n[o].includes("TRACE_FUNC")){let a=`FUNC_${t}::${n[o].trim().split(" ")[1]}`;r&&(a+=`::${r}`),P("CPU",a);return}n[o].includes("TRACE_FUNC")&&(a=!0)}},_=t=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&$("BEGIN",t)},B=t=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&$("END",t)},N=t=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&console.time(`ORT::${t}`)},M=t=>{(typeof c.trace>"u"?c.wasm.trace:c.trace)&&console.timeEnd(`ORT::${t}`)}}),et=G(()=>{"use strict";W(),Y(),ee(),S=class t{constructor(t){this.handler=t}async run(t,r,n){_(),N("InferenceSession.run");let a={},o={};if("object"!=typeof t||null===t||t instanceof x||Array.isArray(t))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let i=!0;if("object"==typeof r){if(null===r)throw TypeError("Unexpected argument[1]: cannot be null.");if(r instanceof x)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(r)){if(0===r.length)throw TypeError("'fetches' cannot be an empty array.");for(let t of(i=!1,r)){if("string"!=typeof t)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(t))throw RangeError(`'fetches' contains invalid output name: ${t}.`);a[t]=null}if("object"==typeof n&&null!==n)o=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else{let t=!1,s=Object.getOwnPropertyNames(r);for(let n of this.outputNames)if(-1!==s.indexOf(n)){let o=r[n];(null===o||o instanceof x)&&(t=!0,i=!1,a[n]=o)}if(t){if("object"==typeof n&&null!==n)o=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else o=r}}else if("u">typeof r)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let r of this.inputNames)if(typeof t[r]>"u")throw Error(`input '${r}' is missing in 'feeds'.`);if(i)for(let t of this.outputNames)a[t]=null;let s=await this.handler.run(t,a,o),u={};for(let t in s)if(Object.hasOwnProperty.call(s,t)){let r=s[t];r instanceof x?u[t]=r:u[t]=new x(r.type,r.data,r.dims)}return M("InferenceSession.run"),B(),u}async release(){return this.handler.dispose()}static async create(r,n,a,o){_(),N("InferenceSession.create");let i,s={};if("string"==typeof r){if(i=r,"object"==typeof n&&null!==n)s=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else if(r instanceof Uint8Array){if(i=r,"object"==typeof n&&null!==n)s=n;else if("u">typeof n)throw TypeError("'options' must be an object.")}else if(r instanceof ArrayBuffer||"u">typeof SharedArrayBuffer&&r instanceof SharedArrayBuffer){let t=0,u=r.byteLength;if("object"==typeof n&&null!==n)s=n;else if("number"==typeof n){if(!Number.isSafeInteger(t=n))throw RangeError("'byteOffset' must be an integer.");if(t<0||t>=r.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${r.byteLength}).`);if(u=r.byteLength-t,"number"==typeof a){if(!Number.isSafeInteger(u=a))throw RangeError("'byteLength' must be an integer.");if(u<=0||t+u>r.byteLength)throw RangeError(`'byteLength' is out of range (0, ${r.byteLength-t}].`);if("object"==typeof o&&null!==o)s=o;else if("u">typeof o)throw TypeError("'options' must be an object.")}else if("u">typeof a)throw TypeError("'byteLength' must be a number.")}else if("u">typeof n)throw TypeError("'options' must be an object.");i=new Uint8Array(r,t,u)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[u,l]=await f(s),p=await u.createInferenceSessionHandler(i,l);return M("InferenceSession.create"),B(),new t(p)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}),er=G(()=>{"use strict";et(),k=S}),en=G(()=>{}),ea=G(()=>{}),eo=G(()=>{}),ei=G(()=>{}),es={};F(es,{InferenceSession:()=>k,TRACE:()=>P,TRACE_EVENT_BEGIN:()=>N,TRACE_EVENT_END:()=>M,TRACE_FUNC_BEGIN:()=>_,TRACE_FUNC_END:()=>B,Tensor:()=>x,env:()=>h,registerBackend:()=>u});var eu=G(()=>{"use strict";V(),q(),er(),Y(),en(),ea(),ee(),eo(),ei()}),el=G(()=>{}),ef={};F(ef,{default:()=>ed});var ep,ed,ec,eh,em,ey,eg,ew,eb,ev,eE,eT,eA,eC,eR,eO,eU,eI,eL,ex,eP,e$,e_,eB,eN,eM,eS,ek,eD,eG,eF,ej,eW,eV,eH,ez,eq,eZ,eJ,eK,eQ,eX,eY,e0,e1,e2,e3,e6,e4,e8,e5,e9,e7,te,tt,tr,tn,ta,to,ti,ts,tu,tl,tf,tp,td,tc,th=G(()=>{"use strict";tT(),ty(),tm(),(ep=globalThis.self?.name==="ort-wasm-proxy-worker")&&(self.onmessage=t=>{let{type:r,in:n}=t.data;try{switch(r){case"init-wasm":eI(n.wasm).then(()=>{ez(n).then(()=>{postMessage({type:r})},t=>{postMessage({type:r,err:t})})},t=>{postMessage({type:r,err:t})});break;case"init-ep":{let{epName:t,env:a}=n;eq(a,t).then(()=>{postMessage({type:r})},t=>{postMessage({type:r,err:t})});break}case"copy-from":{let{buffer:t}=n,a=eK(t);postMessage({type:r,out:a});break}case"create":{let{model:t,options:a}=n;eQ(t,a).then(t=>{postMessage({type:r,out:t})},t=>{postMessage({type:r,err:t})});break}case"release":eX(n),postMessage({type:r});break;case"run":{let{sessionId:t,inputIndices:a,inputs:o,outputIndices:i,options:s}=n;e0(t,a,o,i,Array(i.length).fill(null),s).then(t=>{t.some(t=>"cpu"!==t[3])?postMessage({type:r,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:r,out:t},e2([...o,...t]))},t=>{postMessage({type:r,err:t})});break}case"end-profiling":e1(n),postMessage({type:r})}}catch(t){postMessage({type:r,err:t})}}),ed=ep?null:t=>new Worker(t??em,{type:"module",name:"ort-wasm-proxy-worker"})}),tm=G(()=>{"use strict";el(),ec=typeof location>"u"?void 0:location.origin,eh=import.meta.url>"file:"&&import.meta.url<"file;",em=(()=>{if(eh){let t=URL;return new URL(new t("ort.wasm.min.mjs",import.meta.url).href,ec).href}return import.meta.url})(),ey=()=>{if(em&&!em.startsWith("blob:"))return em.substring(0,em.lastIndexOf("/")+1)},eg=(t,r)=>{try{let n=r??em;return(n?new URL(t,n):new URL(t)).origin===ec}catch{return!1}},ew=async t=>{let r=await (await fetch(t,{credentials:"same-origin"})).blob();return URL.createObjectURL(r)},eb=async t=>(await import(t)).default,ev=(th(),j(ef)).default,eE=async()=>{if(!em)throw Error("Failed to load proxy worker: cannot determine the script source URL.");if(eg(em))return[void 0,ev()];let t=await ew(em);return[t,ev(t)]},eT=void 0,eA=async(t,r,n,a)=>{let o=eT&&!(t||r);if(o)if(em)o=eg(em);else if(a&&!n)o=!0;else throw Error("cannot determine the script source URL.");if(o)return[void 0,eT];{let a,o,i="ort-wasm-simd-threaded.mjs",s=t??((t,r)=>{let n=r??em;try{return(n?new URL(t,n):new URL(t)).href}catch{return}})(i,r),u=n&&s&&!eg(s,r),l=u?await ew(s):s??(a=i,o=r,`${o??"./"}${a}`);return[u?l:void 0,await eb(l)]}}}),ty=G(()=>{"use strict";tm(),eR=!1,eO=!1,eU=!1,eI=async t=>{if(eR)return Promise.resolve();if(eO)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(eU)throw Error("previous call to 'initializeWebAssembly()' failed.");eO=!0;let r=t.initTimeout,n=t.numThreads;if(!1!==t.simd){if("relaxed"===t.simd){if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}})())throw Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})())throw Error("WebAssembly SIMD is not supported in the current environment.")}let a=(()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return"u">typeof MessageChannel&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}})();n>1&&!a&&("u">typeof self&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+n+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),t.numThreads=n=1);let o=t.wasmPaths,i="string"==typeof o?o:void 0,s=o?.mjs,u=s?.href??s,l=o?.wasm,f=l?.href??l,p=t.wasmBinary,[d,c]=await eA(u,i,n>1,!!p||!!f),h=!1,m=[];if(r>0&&m.push(new Promise(t=>{setTimeout(()=>{h=!0,t()},r)})),m.push(new Promise((t,r)=>{let a={numThreads:n};if(p)a.wasmBinary=p;else if(f||i)a.locateFile=t=>f??i+t;else if(u&&0!==u.indexOf("blob:"))a.locateFile=t=>new URL(t,u).href;else if(d){let t=ey();t&&(a.locateFile=r=>t+r)}c(a).then(r=>{eO=!1,eR=!0,eC=r,t(),d&&URL.revokeObjectURL(d)},t=>{eO=!1,eU=!0,r(t)})})),await Promise.race(m),h)throw Error(`WebAssembly backend initializing failed due to timeout: ${r}ms`)},eL=()=>{if(eR&&eC)return eC;throw Error("WebAssembly is not initialized yet.")}}),tg=G(()=>{"use strict";ty(),ex=(t,r)=>{let n=eL(),a=n.lengthBytesUTF8(t)+1,o=n._malloc(a);return n.stringToUTF8(t,o,a),r.push(o),o},eP=(t,r,n,a)=>{if("object"==typeof t&&null!==t){if(n.has(t))throw Error("Circular reference in options");n.add(t)}Object.entries(t).forEach(([t,o])=>{let i=r?r+t:t;if("object"==typeof o)eP(o,i+".",n,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else if("boolean"==typeof o)a(i,o?"1":"0");else throw Error(`Can't handle extra config type: ${typeof o}`)})},e$=t=>{let r=eL(),n=r.stackSave();try{let n=r.PTR_SIZE,a=r.stackAlloc(2*n);r._OrtGetLastError(a,a+n);let o=Number(r.getValue(a,4===n?"i32":"i64")),i=r.getValue(a+n,"*"),s=i?r.UTF8ToString(i):"";throw Error(`${t} ERROR_CODE: ${o}, ERROR_MESSAGE: ${s}`)}finally{r.stackRestore(n)}}}),tw=G(()=>{"use strict";ty(),tg(),e_=t=>{let r=eL(),n=0,a=[],o=t||{};try{if(t?.logSeverityLevel===void 0)o.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw Error(`log severity level is not valid: ${t.logSeverityLevel}`);if(t?.logVerbosityLevel===void 0)o.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);t?.terminate===void 0&&(o.terminate=!1);let i=0;return t?.tag!==void 0&&(i=ex(t.tag,a)),n=r._OrtCreateRunOptions(o.logSeverityLevel,o.logVerbosityLevel,!!o.terminate,i),0===n&&e$("Can't create run options."),t?.extra!==void 0&&eP(t.extra,"",new WeakSet,(t,o)=>{let i=ex(t,a),s=ex(o,a);0!==r._OrtAddRunConfigEntry(n,i,s)&&e$(`Can't set a run config entry: ${t} - ${o}.`)}),[n,a]}catch(t){throw 0!==n&&r._OrtReleaseRunOptions(n),a.forEach(t=>r._free(t)),t}}}),tb=G(()=>{"use strict";ty(),tg(),eB=(t,r,n,a)=>{let o=ex(r,a),i=ex(n,a);0!==eL()._OrtAddSessionConfigEntry(t,o,i)&&e$(`Can't set a session config entry: ${r} - ${n}.`)},eN=async(t,r,n)=>{for(let a of r){let r="string"==typeof a?a:a.name,o=[];switch(r){case"webnn":if(r="WEBNN","string"!=typeof a){let r=a?.deviceType;r&&eB(t,"deviceType",r,n)}break;case"webgpu":if(r="JS","string"!=typeof a&&a?.preferredLayout){if("NCHW"!==a.preferredLayout&&"NHWC"!==a.preferredLayout)throw Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${a.preferredLayout}`);eB(t,"preferredLayout",a.preferredLayout,n)}break;case"wasm":case"cpu":continue;default:throw Error(`not supported execution provider: ${r}`)}let i=ex(r,n),s=o.length,u=0,l=0;if(s>0){u=eL()._malloc(s*eL().PTR_SIZE),n.push(u),l=eL()._malloc(s*eL().PTR_SIZE),n.push(l);for(let t=0;t<s;t++)eL().setValue(u+t*eL().PTR_SIZE,o[t][0],"*"),eL().setValue(l+t*eL().PTR_SIZE,o[t][1],"*")}await eL()._OrtAppendExecutionProvider(t,i,u,l,s)!==0&&e$(`Can't append execution provider: ${r}.`)}},eM=async t=>{var r;let n,a=eL(),o=0,i=[],s=t||{};(r=s).extra||(r.extra={}),r.extra.session||(r.extra.session={}),(n=r.extra.session).use_ort_model_bytes_directly||(n.use_ort_model_bytes_directly="1"),r.executionProviders&&r.executionProviders.some(t=>("string"==typeof t?t:t.name)==="webgpu")&&(r.enableMemPattern=!1);try{let t=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${t}`)}})(s.graphOptimizationLevel??"all"),r=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${t}`)}})(s.executionMode??"sequential"),n="string"==typeof s.logId?ex(s.logId,i):0,u=s.logSeverityLevel??2;if(!Number.isInteger(u)||u<0||u>4)throw Error(`log severity level is not valid: ${u}`);let l=s.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw Error(`log verbosity level is not valid: ${l}`);let f="string"==typeof s.optimizedModelFilePath?ex(s.optimizedModelFilePath,i):0;if(o=a._OrtCreateSessionOptions(t,!!s.enableCpuMemArena,!!s.enableMemPattern,r,!!s.enableProfiling,0,n,u,l,f),0===o&&e$("Can't create session options."),s.executionProviders&&await eN(o,s.executionProviders,i),void 0!==s.enableGraphCapture){if("boolean"!=typeof s.enableGraphCapture)throw Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);eB(o,"enableGraphCapture",s.enableGraphCapture.toString(),i)}if(s.freeDimensionOverrides)for(let[t,r]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof t)throw Error(`free dimension override name must be a string: ${t}`);if("number"!=typeof r||!Number.isInteger(r)||r<0)throw Error(`free dimension override value must be a non-negative integer: ${r}`);let n=ex(t,i);0!==a._OrtAddFreeDimensionOverride(o,n,r)&&e$(`Can't set a free dimension override: ${t} - ${r}.`)}return void 0!==s.extra&&eP(s.extra,"",new WeakSet,(t,r)=>{eB(o,t,r,i)}),[o,i]}catch(t){throw 0!==o&&0!==a._OrtReleaseSessionOptions(o)&&e$("Can't release session options."),i.forEach(t=>a._free(t)),t}}}),tv=G(()=>{"use strict";eS=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw Error(`unsupported data type: ${t}`)}},ek=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw Error(`unsupported data type: ${t}`)}},eD=(t,r)=>{let n=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][t],a="number"==typeof r?r:r.reduce((t,r)=>t*r,1);return n>0?Math.ceil(a*n):void 0},eG=t=>{switch(t){case"float16":return"u">typeof Float16Array&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${t}`)}},eF=t=>{switch(t){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${t}`)}},ej=t=>"float32"===t||"float16"===t||"int32"===t||"int64"===t||"uint32"===t||"uint8"===t||"bool"===t||"uint4"===t||"int4"===t,eW=t=>"float32"===t||"float16"===t||"int32"===t||"int64"===t||"uint32"===t||"uint64"===t||"int8"===t||"uint8"===t||"bool"===t||"uint4"===t||"int4"===t,eV=t=>{switch(t){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw Error(`unsupported data location: ${t}`)}}}),tE=G(()=>{"use strict";el(),eH=async t=>{if("string"!=typeof t)return t instanceof Blob?new Uint8Array(await t.arrayBuffer()):t instanceof Uint8Array?t:new Uint8Array(t);{let r=await fetch(t);if(!r.ok)throw Error(`failed to load external data file: ${t}`);let n=r.headers.get("Content-Length"),a=n?parseInt(n,10):0;if(a<0x40000000)return new Uint8Array(await r.arrayBuffer());{if(!r.body)throw Error(`failed to load external data file: ${t}, no response body.`);let n=r.body.getReader(),o;try{o=new ArrayBuffer(a)}catch(t){if(t instanceof RangeError){let t=Math.ceil(a/65536);o=new WebAssembly.Memory({initial:t,maximum:t}).buffer}else throw t}let i=0;for(;;){let{done:t,value:r}=await n.read();if(t)break;let a=r.byteLength;new Uint8Array(o,i,a).set(r),i+=a}return new Uint8Array(o,0,a)}}}}),tT=G(()=>{"use strict";eu(),tw(),tb(),tv(),ty(),tg(),tE(),ez=async t=>{var r,n;r=t.wasm.numThreads,n=eF(t.logLevel),0!==eL()._OrtInit(r,n)&&e$("Can't initialize onnxruntime.")},eq=async(t,r)=>{eL().asyncInit?.();let n=t.webgpu.adapter;if("webgpu"===r){if(typeof navigator>"u"||!navigator.gpu)throw Error("WebGPU is not supported in current environment");if(n){if("object"!=typeof n.limits||"object"!=typeof n.features||"function"!=typeof n.requestDevice)throw Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let r=t.webgpu.powerPreference;if(void 0!==r&&"low-power"!==r&&"high-performance"!==r)throw Error(`Invalid powerPreference setting: "${r}"`);let a=t.webgpu.forceFallbackAdapter;if(void 0!==a&&"boolean"!=typeof a)throw Error(`Invalid forceFallbackAdapter setting: "${a}"`);if(!(n=await navigator.gpu.requestAdapter({powerPreference:r,forceFallbackAdapter:a})))throw Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if("webnn"===r&&(typeof navigator>"u"||!navigator.ml))throw Error("WebNN is not supported in current environment")},eZ=new Map,eJ=(t,r)=>{let n=eL(),a=n.stackSave(),o=0;try{let a=n.PTR_SIZE,i=n.stackAlloc(2*a);0!==n._OrtGetInputOutputMetadata(t,r,i,i+a)&&e$("Can't get session input/output metadata.");let s=Number(n.getValue(i,"*"));o=Number(n.getValue(i+a,"*"));let u=n.HEAP32[o/4];if(0===u)return[s,0];let l=n.HEAPU32[o/4+1],f=[];for(let t=0;t<l;t++){let r=Number(n.getValue(o+8+t*a,"*"));f.push(0!==r?n.UTF8ToString(r):Number(n.getValue(o+8+(t+l)*a,"*")))}return[s,u,f]}finally{n.stackRestore(a),0!==o&&n._OrtFree(o)}},eK=t=>{let r=eL(),n=r._malloc(t.byteLength);if(0===n)throw Error(`Can't create a session. failed to allocate a buffer of size ${t.byteLength}.`);return r.HEAPU8.set(t,n),[n,t.byteLength]},eQ=async(t,r)=>{let n,a,o=eL();Array.isArray(t)?[n,a]=t:t.buffer===o.HEAPU8.buffer?[n,a]=[t.byteOffset,t.byteLength]:[n,a]=eK(t);let i=0,s=0,u=[],l=[],f=[];try{if([s,u]=await eM(r),r?.externalData&&o.mountExternalData){let t=[];for(let n of r.externalData){let r="string"==typeof n?n:n.path;t.push(eH("string"==typeof n?n:n.data).then(t=>{o.mountExternalData(r,t)}))}await Promise.all(t)}for(let t of r?.executionProviders??[])if(("string"==typeof t?t:t.name)==="webnn"){if(o.shouldTransferToMLTensor=!1,"string"!=typeof t){let r=t?.context,n=t?.gpuDevice,a=t?.deviceType,i=t?.powerPreference;r?o.currentContext=r:n?o.currentContext=await o.webnnCreateMLContext(n):o.currentContext=await o.webnnCreateMLContext({deviceType:a,powerPreference:i})}else o.currentContext=await o.webnnCreateMLContext();break}i=await o._OrtCreateSession(n,a,s),o.webgpuOnCreateSession?.(i),0===i&&e$("Can't create a session."),o.jsepOnCreateSession?.(),o.currentContext&&(o.webnnRegisterMLContext(i,o.currentContext),o.currentContext=void 0,o.shouldTransferToMLTensor=!0);let[t,p]=(t=>{let r=eL(),n=r.stackSave();try{let n=r.PTR_SIZE,a=r.stackAlloc(2*n);0!==r._OrtGetInputOutputCount(t,a,a+n)&&e$("Can't get session input/output count.");let o=4===n?"i32":"i64";return[Number(r.getValue(a,o)),Number(r.getValue(a+n,o))]}finally{r.stackRestore(n)}})(i),d=!!r?.enableGraphCapture,c=[],h=[],m=[],y=[];for(let r=0;r<t;r++){let[t,n,a]=eJ(i,r);0===t&&e$("Can't get an input name."),l.push(t);let s=o.UTF8ToString(t);c.push(s),m.push(0===n?{name:s,isTensor:!1}:{name:s,isTensor:!0,type:ek(n),shape:a})}for(let r=0;r<p;r++){let[n,a,s]=eJ(i,r+t);0===n&&e$("Can't get an output name."),f.push(n);let u=o.UTF8ToString(n);h.push(u),y.push(0===a?{name:u,isTensor:!1}:{name:u,isTensor:!0,type:ek(a),shape:s})}return eZ.set(i,[i,l,f,null,d,!1]),[i,c,h,m,y]}catch(t){throw l.forEach(t=>o._OrtFree(t)),f.forEach(t=>o._OrtFree(t)),0!==i&&0!==o._OrtReleaseSession(i)&&e$("Can't release session."),t}finally{o._free(n),0!==s&&0!==o._OrtReleaseSessionOptions(s)&&e$("Can't release session options."),u.forEach(t=>o._free(t)),o.unmountExternalData?.()}},eX=t=>{let r=eL(),n=eZ.get(t);if(!n)throw Error(`cannot release session. invalid session id: ${t}`);let[a,o,i,s,u]=n;s&&(u&&0!==r._OrtClearBoundOutputs(s.handle)&&e$("Can't clear bound outputs."),0!==r._OrtReleaseBinding(s.handle)&&e$("Can't release IO binding.")),r.jsepOnReleaseSession?.(t),r.webnnOnReleaseSession?.(t),r.webgpuOnReleaseSession?.(t),o.forEach(t=>r._OrtFree(t)),i.forEach(t=>r._OrtFree(t)),0!==r._OrtReleaseSession(a)&&e$("Can't release session."),eZ.delete(t)},eY=async(t,r,n,a,o,i,s=!1)=>{if(!t)return void r.push(0);let u=eL(),l=u.PTR_SIZE,f=t[0],p=t[1],d=t[3],c=d,h,m;if("string"===f&&("gpu-buffer"===d||"ml-tensor"===d))throw Error("String tensor is not supported on GPU.");if(s&&"gpu-buffer"!==d)throw Error(`External buffer must be provided for input/output index ${i} when enableGraphCapture is true.`);if("gpu-buffer"===d){let r=t[2].gpuBuffer;m=eD(eS(f),p);{let t=u.jsepRegisterBuffer;if(!t)throw Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');h=t(a,i,r,m)}}else if("ml-tensor"===d){let r=t[2].mlTensor;m=eD(eS(f),p);let n=u.webnnRegisterMLTensor;if(!n)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');h=n(a,r,eS(f),p)}else{let r=t[2];if(Array.isArray(r)){m=l*r.length,h=u._malloc(m),n.push(h);for(let t=0;t<r.length;t++){if("string"!=typeof r[t])throw TypeError(`tensor data at index ${t} is not a string`);u.setValue(h+t*l,ex(r[t],n),"*")}}else{let t=u.webnnIsGraphInput,i=u.webnnIsGraphOutput;if("string"!==f&&t&&i){let s=u.UTF8ToString(o);if(t(a,s)||i(a,s)){let t=eS(f);m=eD(t,p),c="ml-tensor";let n=u.webnnCreateTemporaryTensor,o=u.webnnUploadTensor;if(!n||!o)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');let i=await n(a,t,p);o(i,new Uint8Array(r.buffer,r.byteOffset,r.byteLength)),h=i}else m=r.byteLength,h=u._malloc(m),n.push(h),u.HEAPU8.set(new Uint8Array(r.buffer,r.byteOffset,m),h)}else m=r.byteLength,h=u._malloc(m),n.push(h),u.HEAPU8.set(new Uint8Array(r.buffer,r.byteOffset,m),h)}}let y=u.stackSave(),g=u.stackAlloc(4*p.length);try{p.forEach((t,r)=>u.setValue(g+r*l,t,4===l?"i32":"i64"));let t=u._OrtCreateTensor(eS(f),h,m,g,p.length,eV(c));0===t&&e$(`Can't create tensor for input/output. session=${a}, index=${i}.`),r.push(t)}finally{u.stackRestore(y)}},e0=async(t,r,n,a,o,i)=>{let s=eL(),u=s.PTR_SIZE,l=eZ.get(t);if(!l)throw Error(`cannot run inference. invalid session id: ${t}`);let f=l[0],p=l[1],d=l[2],c=l[3],h=l[4],m=(l[5],r.length),y=a.length,g=0,w=[],b=[],v=[],E=[],T=s.stackSave(),A=s.stackAlloc(m*u),C=s.stackAlloc(m*u),R=s.stackAlloc(y*u),O=s.stackAlloc(y*u);try{let l;[g,w]=e_(i),N("wasm prepareInputOutputTensor");for(let a=0;a<m;a++)await eY(n[a],b,E,t,p[r[a]],r[a],h);for(let r=0;r<y;r++)await eY(o[r],v,E,t,d[a[r]],m+a[r],h);M("wasm prepareInputOutputTensor");for(let t=0;t<m;t++)s.setValue(A+t*u,b[t],"*"),s.setValue(C+t*u,p[r[t]],"*");for(let t=0;t<y;t++)s.setValue(R+t*u,v[t],"*"),s.setValue(O+t*u,d[a[t]],"*");s.jsepOnRunStart?.(f),s.webnnOnRunStart?.(f),l=await s._OrtRun(f,C,A,m,O,y,R,g),0!==l&&e$("failed to call OrtRun().");let T=[],U=[];N("wasm ProcessOutputTensor");for(let r=0;r<y;r++){let n=Number(s.getValue(R+r*u,"*"));if(n===v[r]){T.push(o[r]);continue}let i=s.stackSave(),l=s.stackAlloc(4*u),f=!1,p,d=0;try{0!==s._OrtGetTensorData(n,l,l+u,l+2*u,l+3*u)&&e$(`Can't access output tensor data on index ${r}.`);let o=4===u?"i32":"i64",i=Number(s.getValue(l,o));d=s.getValue(l+u,"*");let h=s.getValue(l+2*u,"*"),m=Number(s.getValue(l+3*u,o)),y=[];for(let t=0;t<m;t++)y.push(Number(s.getValue(h+t*u,o)));0!==s._OrtFree(h)&&e$("Can't free memory for tensor dims.");let g=y.reduce((t,r)=>t*r,1);p=ek(i);let w=c?.outputPreferredLocations[a[r]];if("string"===p){if("gpu-buffer"===w||"ml-tensor"===w)throw Error("String tensor is not supported on GPU.");let t=[];for(let r=0;r<g;r++){let n=s.getValue(d+r*u,"*"),a=s.getValue(d+(r+1)*u,"*"),o=r===g-1?void 0:a-n;t.push(s.UTF8ToString(n,o))}T.push([p,y,t,"cpu"])}else if("gpu-buffer"===w&&g>0){let t=s.jsepGetBuffer;if(!t)throw Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let r=t(d),a=eD(i,g);if(void 0===a||!ej(p))throw Error(`Unsupported data type: ${p}`);f=!0,T.push([p,y,{gpuBuffer:r,download:s.jsepCreateDownloader(r,a,p),dispose:()=>{0!==s._OrtReleaseTensor(n)&&e$("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===w&&g>0){let r=s.webnnEnsureTensor,a=s.webnnIsGraphInputOutputTypeSupported;if(!r||!a)throw Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===eD(i,g)||!eW(p))throw Error(`Unsupported data type: ${p}`);if(!a(t,p,!1))throw Error(`preferredLocation "ml-tensor" for ${p} output is not supported by current WebNN Context.`);let o=await r(t,d,i,y,!1);f=!0,T.push([p,y,{mlTensor:o,download:s.webnnCreateMLTensorDownloader(d,p),dispose:()=>{s.webnnReleaseTensorId(d),s._OrtReleaseTensor(n)}},"ml-tensor"])}else if("ml-tensor-cpu-output"===w&&g>0){let t=s.webnnCreateMLTensorDownloader(d,p)(),r=T.length;f=!0,U.push((async()=>{let a=[r,await t];return s.webnnReleaseTensorId(d),s._OrtReleaseTensor(n),a})()),T.push([p,y,[],"cpu"])}else{let t=new(eG(p))(g);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(s.HEAPU8.subarray(d,d+t.byteLength)),T.push([p,y,t,"cpu"])}}finally{s.stackRestore(i),"string"===p&&d&&s._free(d),f||s._OrtReleaseTensor(n)}}for(let[r,n]of(c&&!h&&(0!==s._OrtClearBoundOutputs(c.handle)&&e$("Can't clear bound outputs."),eZ.set(t,[f,p,d,c,h,!1])),await Promise.all(U)))T[r][2]=n;return M("wasm ProcessOutputTensor"),T}finally{s.webnnOnRunEnd?.(f),s.stackRestore(T),b.forEach(t=>s._OrtReleaseTensor(t)),v.forEach(t=>s._OrtReleaseTensor(t)),E.forEach(t=>s._free(t)),0!==g&&s._OrtReleaseRunOptions(g),w.forEach(t=>s._free(t))}},e1=t=>{let r=eL(),n=eZ.get(t);if(!n)throw Error("invalid session id");let a=n[0],o=r._OrtEndProfiling(a);0===o&&e$("Can't get an profile file name."),r._OrtFree(o)},e2=t=>{let r=[];for(let n of t){let t=n[2];!Array.isArray(t)&&"buffer"in t&&r.push(t.buffer)}return r}}),tA=G(()=>{"use strict";eu(),tT(),ty(),tm(),e3=()=>!!h.wasm.proxy&&"u">typeof document,e4=!1,e8=!1,e5=!1,te=new Map,tt=(t,r)=>{let n=te.get(t);n?n.push(r):te.set(t,[r])},tr=()=>{if(e4||!e8||e5||!e6)throw Error("worker not ready")},tn=t=>{switch(t.data.type){case"init-wasm":e4=!1,t.data.err?(e5=!0,e7[1](t.data.err)):(e8=!0,e7[0]()),e9&&(URL.revokeObjectURL(e9),e9=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let r=te.get(t.data.type);t.data.err?r.shift()[1](t.data.err):r.shift()[0](t.data.out)}}},ta=async()=>{if(!e8){if(e4)throw Error("multiple calls to 'initWasm()' detected.");if(e5)throw Error("previous call to 'initWasm()' failed.");if(e4=!0,e3())return new Promise((t,r)=>{e6?.terminate(),eE().then(([n,a])=>{try{(e6=a).onerror=t=>r(t),e6.onmessage=tn,e7=[t,r];let o={type:"init-wasm",in:h};if(!o.in.wasm.wasmPaths&&n){let t=ey();t&&(o.in.wasm.wasmPaths=t)}e6.postMessage(o),e9=n}catch(t){r(t)}},r)});try{await eI(h.wasm),await ez(h),e8=!0}catch(t){throw e5=!0,t}finally{e4=!1}}},to=async t=>{if(e3())return tr(),new Promise((r,n)=>{tt("init-ep",[r,n]);let a={type:"init-ep",in:{epName:t,env:h}};e6.postMessage(a)});await eq(h,t)},ti=async t=>e3()?(tr(),new Promise((r,n)=>{tt("copy-from",[r,n]),e6.postMessage({type:"copy-from",in:{buffer:t}},[t.buffer])})):eK(t),ts=async(t,r)=>{if(!e3())return eQ(t,r);if(r?.preferredOutputLocation)throw Error('session option "preferredOutputLocation" is not supported for proxy.');return tr(),new Promise((n,a)=>{tt("create",[n,a]);let o={type:"create",in:{model:t,options:{...r}}},i=[];t instanceof Uint8Array&&i.push(t.buffer),e6.postMessage(o,i)})},tu=async t=>{if(e3())return tr(),new Promise((r,n)=>{tt("release",[r,n]),e6.postMessage({type:"release",in:t})});eX(t)},tl=async(t,r,n,a,o,i)=>{if(!e3())return e0(t,r,n,a,o,i);if(n.some(t=>"cpu"!==t[3]))throw Error("input tensor on GPU is not supported for proxy.");if(o.some(t=>t))throw Error("pre-allocated output tensor is not supported for proxy.");return tr(),new Promise((o,s)=>{tt("run",[o,s]),e6.postMessage({type:"run",in:{sessionId:t,inputIndices:r,inputs:n,outputIndices:a,options:i}},e2(n))})},tf=async t=>{if(e3())return tr(),new Promise((r,n)=>{tt("end-profiling",[r,n]),e6.postMessage({type:"end-profiling",in:t})});e1(t)}}),tC=G(()=>{"use strict";eu(),tA(),tv(),el(),tE(),tp=(t,r)=>{switch(t.location){case"cpu":return[t.type,t.dims,t.data,"cpu"];case"gpu-buffer":return[t.type,t.dims,{gpuBuffer:t.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[t.type,t.dims,{mlTensor:t.mlTensor},"ml-tensor"];default:throw Error(`invalid data location: ${t.location} for ${r()}`)}},td=t=>{switch(t[3]){case"cpu":return new x(t[0],t[2],t[1]);case"gpu-buffer":{let r=t[0];if(!ej(r))throw Error(`not supported data type: ${r} for deserializing GPU tensor`);let{gpuBuffer:n,download:a,dispose:o}=t[2];return x.fromGpuBuffer(n,{dataType:r,dims:t[1],download:a,dispose:o})}case"ml-tensor":{let r=t[0];if(!eW(r))throw Error(`not supported data type: ${r} for deserializing MLTensor tensor`);let{mlTensor:n,download:a,dispose:o}=t[2];return x.fromMLTensor(n,{dataType:r,dims:t[1],download:a,dispose:o})}default:throw Error(`invalid data location: ${t[3]}`)}},tc=class{async fetchModelAndCopyToWasmMemory(t){return ti(await eH(t))}async loadModel(t,r){let n;_(),n="string"==typeof t?await this.fetchModelAndCopyToWasmMemory(t):t,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await ts(n,r),B()}async dispose(){return tu(this.sessionId)}async run(t,r,n){_();let a=[],o=[];Object.entries(t).forEach(t=>{let r=t[0],n=t[1],i=this.inputNames.indexOf(r);if(-1===i)throw Error(`invalid input '${r}'`);a.push(n),o.push(i)});let i=[],s=[];Object.entries(r).forEach(t=>{let r=t[0],n=t[1],a=this.outputNames.indexOf(r);if(-1===a)throw Error(`invalid output '${r}'`);i.push(n),s.push(a)});let u=a.map((t,r)=>tp(t,()=>`input "${this.inputNames[o[r]]}"`)),l=i.map((t,r)=>t?tp(t,()=>`output "${this.outputNames[s[r]]}"`):null),f=await tl(this.sessionId,o,u,s,l,n),p={};for(let t=0;t<f.length;t++)p[this.outputNames[s[t]]]=i[t]??td(f[t]);return B(),p}startProfiling(){}endProfiling(){tf(this.sessionId)}}}),tR={};F(tR,{OnnxruntimeWebAssemblyBackend:()=>tU,initializeFlags:()=>tO,wasmBackend:()=>tI});var tO,tU,tI,tL=G(()=>{"use strict";eu(),tA(),tC(),tO=()=>{("number"!=typeof h.wasm.initTimeout||h.wasm.initTimeout<0)&&(h.wasm.initTimeout=0);let t=h.wasm.simd;if("boolean"!=typeof t&&void 0!==t&&"fixed"!==t&&"relaxed"!==t&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${t}". Reset it to \`false\` and ignore SIMD feature checking.`),h.wasm.simd=!1),"boolean"!=typeof h.wasm.proxy&&(h.wasm.proxy=!1),"boolean"!=typeof h.wasm.trace&&(h.wasm.trace=!1),"number"!=typeof h.wasm.numThreads||!Number.isInteger(h.wasm.numThreads)||h.wasm.numThreads<=0)if("u">typeof self&&!self.crossOriginIsolated)h.wasm.numThreads=1;else{let t=typeof navigator>"u"?D("node:os").cpus().length:navigator.hardwareConcurrency;h.wasm.numThreads=Math.min(4,Math.ceil((t||1)/2))}},tI=new(tU=class{async init(t){tO(),await ta(),await to(t)}async createInferenceSessionHandler(t,r){let n=new tc;return await n.loadModel(t,r),n}})});eu(),eu(),eu();var tx=es;{let t=(tL(),j(tR)).wasmBackend;u("cpu",t,10),u("wasm",t,10)}Object.defineProperty(h.versions,"web",{value:"1.23.2",enumerable:!0});export{k as InferenceSession,P as TRACE,N as TRACE_EVENT_BEGIN,M as TRACE_EVENT_END,_ as TRACE_FUNC_BEGIN,B as TRACE_FUNC_END,x as Tensor,tx as default,h as env,u as registerBackend};