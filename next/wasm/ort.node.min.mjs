/*! For license information please see ort.node.min.mjs.LICENSE.txt */
let e;import{createRequire as t}from"module";let r=t(import.meta.url);var n=Object.defineProperty,a=Object.getOwnPropertyDescriptor,o=Object.getOwnPropertyNames,s=Object.prototype.hasOwnProperty,i,l,u,f,p,c,d,y,m,h,w,b,g,v,E,O,T,C,_,A,R,x,L,S,P,U,I,$,N,k,M,F,V=(e=function(e){if("u">typeof r)return r.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')},"u">typeof r?r:"u">typeof Proxy?new Proxy(e,{get:(e,t)=>("u">typeof r?r:e)[t]}):e),W=(e,t)=>()=>(e&&(t=e(e=0)),t),B=W(()=>{"use strict";i=!!("u">typeof process&&process.versions&&process.versions.node)}),G=W(()=>{"use strict";B(),l=i||typeof location>"u"?void 0:location.origin,u=import.meta.url>"file:"&&import.meta.url<"file;",f=(()=>{if(!i){if(u){let e=URL;return new URL(new e("ort.node.min.mjs",import.meta.url).href,l).href}return import.meta.url}})(),p=()=>{if(f&&!f.startsWith("blob:"))return f.substring(0,f.lastIndexOf("/")+1)},c=(e,t)=>{try{let r=t??f;return(r?new URL(e,r):new URL(e)).origin===l}catch{return!1}},d=async e=>{let t=await (await fetch(e,{credentials:"same-origin"})).blob();return URL.createObjectURL(t)},y=async e=>(await import(e)).default,m=void 0,h=async(e,t,r,n)=>{let a=m&&!(e||t);if(a)if(f)a=c(f);else if(n&&!r)a=!0;else throw Error("cannot determine the script source URL.");if(a)return[void 0,m];{let n,a,o="ort-wasm-simd-threaded.mjs",s=e??((e,t)=>{let r=t??f;try{return(r?new URL(e,r):new URL(e)).href}catch{return}})(o,t),l=!i&&r&&s&&!c(s,t),u=l?await d(s):s??(n=o,a=t,`${a??"./"}${n}`);return[l?u:void 0,await y(u)]}}}),j=W(()=>{"use strict";G(),b=!1,g=!1,v=!1,E=async e=>{if(b)return Promise.resolve();if(g)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(v)throw Error("previous call to 'initializeWebAssembly()' failed.");g=!0;let t=e.initTimeout,r=e.numThreads;if(!1!==e.simd){if("relaxed"===e.simd){if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch{return!1}})())throw Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}})())throw Error("WebAssembly SIMD is not supported in the current environment.")}let n=(()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return"u">typeof MessageChannel&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}})();r>1&&!n&&("u">typeof self&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let a=e.wasmPaths,o="string"==typeof a?a:void 0,s=a?.mjs,i=s?.href??s,l=a?.wasm,u=l?.href??l,f=e.wasmBinary,[c,d]=await h(i,o,r>1,!!f||!!u),y=!1,m=[];if(t>0&&m.push(new Promise(e=>{setTimeout(()=>{y=!0,e()},t)})),m.push(new Promise((e,t)=>{let n={numThreads:r};if(f)n.wasmBinary=f;else if(u||o)n.locateFile=e=>u??o+e;else if(i&&0!==i.indexOf("blob:"))n.locateFile=e=>new URL(e,i).href;else if(c){let e=p();e&&(n.locateFile=t=>e+t)}d(n).then(t=>{g=!1,b=!0,w=t,e(),c&&URL.revokeObjectURL(c)},e=>{g=!1,v=!0,t(e)})})),await Promise.race(m),y)throw Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},O=()=>{if(b&&w)return w;throw Error("WebAssembly is not initialized yet.")}}),D=W(()=>{"use strict";j(),T=(e,t)=>{let r=O(),n=r.lengthBytesUTF8(e)+1,a=r._malloc(n);return r.stringToUTF8(e,a,n),t.push(a),a},C=(e,t,r,n)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw Error("Circular reference in options");r.add(e)}Object.entries(e).forEach(([e,a])=>{let o=t?t+e:e;if("object"==typeof a)C(a,o+".",r,n);else if("string"==typeof a||"number"==typeof a)n(o,a.toString());else if("boolean"==typeof a)n(o,a?"1":"0");else throw Error(`Can't handle extra config type: ${typeof a}`)})},_=e=>{let t=O(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);t._OrtGetLastError(n,n+r);let a=Number(t.getValue(n,4===r?"i32":"i64")),o=t.getValue(n+r,"*"),s=o?t.UTF8ToString(o):"";throw Error(`${e} ERROR_CODE: ${a}, ERROR_MESSAGE: ${s}`)}finally{t.stackRestore(r)}}}),z=W(()=>{"use strict";j(),D(),A=e=>{let t=O(),r=0,n=[],a=e||{};try{if(e?.logSeverityLevel===void 0)a.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw Error(`log severity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)a.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(a.terminate=!1);let o=0;return e?.tag!==void 0&&(o=T(e.tag,n)),r=t._OrtCreateRunOptions(a.logSeverityLevel,a.logVerbosityLevel,!!a.terminate,o),0===r&&_("Can't create run options."),e?.extra!==void 0&&C(e.extra,"",new WeakSet,(e,a)=>{let o=T(e,n),s=T(a,n);0!==t._OrtAddRunConfigEntry(r,o,s)&&_(`Can't set a run config entry: ${e} - ${a}.`)}),[r,n]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),n.forEach(e=>t._free(e)),e}}}),H=W(()=>{"use strict";j(),D(),R=(e,t,r,n)=>{let a=T(t,n),o=T(r,n);0!==O()._OrtAddSessionConfigEntry(e,a,o)&&_(`Can't set a session config entry: ${t} - ${r}.`)},x=async(e,t,r)=>{for(let n of t){let t="string"==typeof n?n:n.name,a=[];switch(t){case"webnn":if(t="WEBNN","string"!=typeof n){let t=n?.deviceType;t&&R(e,"deviceType",t,r)}break;case"webgpu":if(t="JS","string"!=typeof n&&n?.preferredLayout){if("NCHW"!==n.preferredLayout&&"NHWC"!==n.preferredLayout)throw Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${n.preferredLayout}`);R(e,"preferredLayout",n.preferredLayout,r)}break;case"wasm":case"cpu":continue;default:throw Error(`not supported execution provider: ${t}`)}let o=T(t,r),s=a.length,i=0,l=0;if(s>0){i=O()._malloc(s*O().PTR_SIZE),r.push(i),l=O()._malloc(s*O().PTR_SIZE),r.push(l);for(let e=0;e<s;e++)O().setValue(i+e*O().PTR_SIZE,a[e][0],"*"),O().setValue(l+e*O().PTR_SIZE,a[e][1],"*")}await O()._OrtAppendExecutionProvider(e,o,i,l,s)!==0&&_(`Can't append execution provider: ${t}.`)}},L=async e=>{var t;let r,n=O(),a=0,o=[],s=e||{};(t=s).extra||(t.extra={}),t.extra.session||(t.extra.session={}),(r=t.extra.session).use_ort_model_bytes_directly||(r.use_ort_model_bytes_directly="1"),t.executionProviders&&t.executionProviders.some(e=>("string"==typeof e?e:e.name)==="webgpu")&&(t.enableMemPattern=!1);try{let e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${e}`)}})(s.graphOptimizationLevel??"all"),t=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${e}`)}})(s.executionMode??"sequential"),r="string"==typeof s.logId?T(s.logId,o):0,i=s.logSeverityLevel??2;if(!Number.isInteger(i)||i<0||i>4)throw Error(`log severity level is not valid: ${i}`);let l=s.logVerbosityLevel??0;if(!Number.isInteger(l)||l<0||l>4)throw Error(`log verbosity level is not valid: ${l}`);let u="string"==typeof s.optimizedModelFilePath?T(s.optimizedModelFilePath,o):0;if(a=n._OrtCreateSessionOptions(e,!!s.enableCpuMemArena,!!s.enableMemPattern,t,!!s.enableProfiling,0,r,i,l,u),0===a&&_("Can't create session options."),s.executionProviders&&await x(a,s.executionProviders,o),void 0!==s.enableGraphCapture){if("boolean"!=typeof s.enableGraphCapture)throw Error(`enableGraphCapture must be a boolean value: ${s.enableGraphCapture}`);R(a,"enableGraphCapture",s.enableGraphCapture.toString(),o)}if(s.freeDimensionOverrides)for(let[e,t]of Object.entries(s.freeDimensionOverrides)){if("string"!=typeof e)throw Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof t||!Number.isInteger(t)||t<0)throw Error(`free dimension override value must be a non-negative integer: ${t}`);let r=T(e,o);0!==n._OrtAddFreeDimensionOverride(a,r,t)&&_(`Can't set a free dimension override: ${e} - ${t}.`)}return void 0!==s.extra&&C(s.extra,"",new WeakSet,(e,t)=>{R(a,e,t,o)}),[a,o]}catch(e){throw 0!==a&&0!==n._OrtReleaseSessionOptions(a)&&_("Can't release session options."),o.forEach(e=>n._free(e)),e}}}),Z=W(()=>{"use strict";S=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw Error(`unsupported data type: ${e}`)}},P=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw Error(`unsupported data type: ${e}`)}},U=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n="number"==typeof t?t:t.reduce((e,t)=>e*t,1);return r>0?Math.ceil(n*r):void 0},I=e=>{switch(e){case"float16":return"u">typeof Float16Array&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${e}`)}},$=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${e}`)}},N=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,k=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,M=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw Error(`unsupported data location: ${e}`)}}}),q=W(()=>{"use strict";B(),F=async e=>{if("string"!=typeof e)return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e);if(i)try{let{readFile:t}=V("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if("ERR_FS_FILE_TOO_LARGE"===t.code){let{createReadStream:t}=V("node:fs"),r=t(e),n=[];for await(let e of r)n.push(e);return new Uint8Array(Buffer.concat(n))}throw t}{let t=await fetch(e);if(!t.ok)throw Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),n=r?parseInt(r,10):0;if(n<0x40000000)return new Uint8Array(await t.arrayBuffer());{if(!t.body)throw Error(`failed to load external data file: ${e}, no response body.`);let r=t.body.getReader(),a;try{a=new ArrayBuffer(n)}catch(e){if(e instanceof RangeError){let e=Math.ceil(n/65536);a=new WebAssembly.Memory({initial:e,maximum:e}).buffer}else throw e}let o=0;for(;;){let{done:e,value:t}=await r.read();if(e)break;let n=t.byteLength;new Uint8Array(a,o,n).set(t),o+=n}return new Uint8Array(a,0,n)}}}}),J,Y,K,Q,X,ee,et,er,en,ea,eo=W(()=>{"use strict";z(),H(),Z(),j(),D(),q(),J=async e=>{var t,r;t=e.wasm.numThreads,r=$(e.logLevel),0!==O()._OrtInit(t,r)&&_("Can't initialize onnxruntime.")},Y=async(e,t)=>{O().asyncInit?.();let r=e.webgpu.adapter;if("webgpu"===t){if(typeof navigator>"u"||!navigator.gpu)throw Error("WebGPU is not supported in current environment");if(r){if("object"!=typeof r.limits||"object"!=typeof r.features||"function"!=typeof r.requestDevice)throw Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let t=e.webgpu.powerPreference;if(void 0!==t&&"low-power"!==t&&"high-performance"!==t)throw Error(`Invalid powerPreference setting: "${t}"`);let n=e.webgpu.forceFallbackAdapter;if(void 0!==n&&"boolean"!=typeof n)throw Error(`Invalid forceFallbackAdapter setting: "${n}"`);if(!(r=await navigator.gpu.requestAdapter({powerPreference:t,forceFallbackAdapter:n})))throw Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if("webnn"===t&&(typeof navigator>"u"||!navigator.ml))throw Error("WebNN is not supported in current environment")},K=new Map,Q=(e,t)=>{let r=O(),n=r.stackSave(),a=0;try{let n=r.PTR_SIZE,o=r.stackAlloc(2*n);0!==r._OrtGetInputOutputMetadata(e,t,o,o+n)&&_("Can't get session input/output metadata.");let s=Number(r.getValue(o,"*"));a=Number(r.getValue(o+n,"*"));let i=r.HEAP32[a/4];if(0===i)return[s,0];let l=r.HEAPU32[a/4+1],u=[];for(let e=0;e<l;e++){let t=Number(r.getValue(a+8+e*n,"*"));u.push(0!==t?r.UTF8ToString(t):Number(r.getValue(a+8+(e+l)*n,"*")))}return[s,i,u]}finally{r.stackRestore(n),0!==a&&r._OrtFree(a)}},X=e=>{let t=O(),r=t._malloc(e.byteLength);if(0===r)throw Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},ee=async(e,t)=>{let r,n,a=O();Array.isArray(e)?[r,n]=e:e.buffer===a.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=X(e);let o=0,s=0,i=[],l=[],u=[];try{if([s,i]=await L(t),t?.externalData&&a.mountExternalData){let e=[];for(let r of t.externalData){let t="string"==typeof r?r:r.path;e.push(F("string"==typeof r?r:r.data).then(e=>{a.mountExternalData(t,e)}))}await Promise.all(e)}for(let e of t?.executionProviders??[])if(("string"==typeof e?e:e.name)==="webnn"){if(a.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e?.context,r=e?.gpuDevice,n=e?.deviceType,o=e?.powerPreference;t?a.currentContext=t:r?a.currentContext=await a.webnnCreateMLContext(r):a.currentContext=await a.webnnCreateMLContext({deviceType:n,powerPreference:o})}else a.currentContext=await a.webnnCreateMLContext();break}o=await a._OrtCreateSession(r,n,s),a.webgpuOnCreateSession?.(o),0===o&&_("Can't create a session."),a.jsepOnCreateSession?.(),a.currentContext&&(a.webnnRegisterMLContext(o,a.currentContext),a.currentContext=void 0,a.shouldTransferToMLTensor=!0);let[e,f]=(e=>{let t=O(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);0!==t._OrtGetInputOutputCount(e,n,n+r)&&_("Can't get session input/output count.");let a=4===r?"i32":"i64";return[Number(t.getValue(n,a)),Number(t.getValue(n+r,a))]}finally{t.stackRestore(r)}})(o),p=!!t?.enableGraphCapture,c=[],d=[],y=[],m=[];for(let t=0;t<e;t++){let[e,r,n]=Q(o,t);0===e&&_("Can't get an input name."),l.push(e);let s=a.UTF8ToString(e);c.push(s),y.push(0===r?{name:s,isTensor:!1}:{name:s,isTensor:!0,type:P(r),shape:n})}for(let t=0;t<f;t++){let[r,n,s]=Q(o,t+e);0===r&&_("Can't get an output name."),u.push(r);let i=a.UTF8ToString(r);d.push(i),m.push(0===n?{name:i,isTensor:!1}:{name:i,isTensor:!0,type:P(n),shape:s})}return K.set(o,[o,l,u,null,p,!1]),[o,c,d,y,m]}catch(e){throw l.forEach(e=>a._OrtFree(e)),u.forEach(e=>a._OrtFree(e)),0!==o&&0!==a._OrtReleaseSession(o)&&_("Can't release session."),e}finally{a._free(r),0!==s&&0!==a._OrtReleaseSessionOptions(s)&&_("Can't release session options."),i.forEach(e=>a._free(e)),a.unmountExternalData?.()}},et=e=>{let t=O(),r=K.get(e);if(!r)throw Error(`cannot release session. invalid session id: ${e}`);let[n,a,o,s,i]=r;s&&(i&&0!==t._OrtClearBoundOutputs(s.handle)&&_("Can't clear bound outputs."),0!==t._OrtReleaseBinding(s.handle)&&_("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),a.forEach(e=>t._OrtFree(e)),o.forEach(e=>t._OrtFree(e)),0!==t._OrtReleaseSession(n)&&_("Can't release session."),K.delete(e)},er=async(e,t,r,n,a,o,s=!1)=>{if(!e)return void t.push(0);let i=O(),l=i.PTR_SIZE,u=e[0],f=e[1],p=e[3],c=p,d,y;if("string"===u&&("gpu-buffer"===p||"ml-tensor"===p))throw Error("String tensor is not supported on GPU.");if(s&&"gpu-buffer"!==p)throw Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if("gpu-buffer"===p){let t=e[2].gpuBuffer;y=U(S(u),f);{let e=i.jsepRegisterBuffer;if(!e)throw Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');d=e(n,o,t,y)}}else if("ml-tensor"===p){let t=e[2].mlTensor;y=U(S(u),f);let r=i.webnnRegisterMLTensor;if(!r)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');d=r(n,t,S(u),f)}else{let t=e[2];if(Array.isArray(t)){y=l*t.length,d=i._malloc(y),r.push(d);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw TypeError(`tensor data at index ${e} is not a string`);i.setValue(d+e*l,T(t[e],r),"*")}}else{let e=i.webnnIsGraphInput,o=i.webnnIsGraphOutput;if("string"!==u&&e&&o){let s=i.UTF8ToString(a);if(e(n,s)||o(n,s)){let e=S(u);y=U(e,f),c="ml-tensor";let r=i.webnnCreateTemporaryTensor,a=i.webnnUploadTensor;if(!r||!a)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');let o=await r(n,e,f);a(o,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),d=o}else y=t.byteLength,d=i._malloc(y),r.push(d),i.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,y),d)}else y=t.byteLength,d=i._malloc(y),r.push(d),i.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,y),d)}}let m=i.stackSave(),h=i.stackAlloc(4*f.length);try{f.forEach((e,t)=>i.setValue(h+t*l,e,4===l?"i32":"i64"));let e=i._OrtCreateTensor(S(u),d,y,h,f.length,M(c));0===e&&_(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(e)}finally{i.stackRestore(m)}},en=async(e,t,r,n,a,o)=>{let s=O(),i=s.PTR_SIZE,l=K.get(e);if(!l)throw Error(`cannot run inference. invalid session id: ${e}`);let u=l[0],f=l[1],p=l[2],c=l[3],d=l[4],y=(l[5],t.length),m=n.length,h=0,w=[],b=[],g=[],v=[],E=s.stackSave(),T=s.stackAlloc(y*i),C=s.stackAlloc(y*i),R=s.stackAlloc(m*i),x=s.stackAlloc(m*i);try{let l;[h,w]=A(o),eS("wasm prepareInputOutputTensor");for(let n=0;n<y;n++)await er(r[n],b,v,e,f[t[n]],t[n],d);for(let t=0;t<m;t++)await er(a[t],g,v,e,p[n[t]],y+n[t],d);eP("wasm prepareInputOutputTensor");for(let e=0;e<y;e++)s.setValue(T+e*i,b[e],"*"),s.setValue(C+e*i,f[t[e]],"*");for(let e=0;e<m;e++)s.setValue(R+e*i,g[e],"*"),s.setValue(x+e*i,p[n[e]],"*");s.jsepOnRunStart?.(u),s.webnnOnRunStart?.(u),l=await s._OrtRun(u,C,T,y,x,m,R,h),0!==l&&_("failed to call OrtRun().");let E=[],O=[];eS("wasm ProcessOutputTensor");for(let t=0;t<m;t++){let r=Number(s.getValue(R+t*i,"*"));if(r===g[t]){E.push(a[t]);continue}let o=s.stackSave(),l=s.stackAlloc(4*i),u=!1,f,p=0;try{0!==s._OrtGetTensorData(r,l,l+i,l+2*i,l+3*i)&&_(`Can't access output tensor data on index ${t}.`);let a=4===i?"i32":"i64",o=Number(s.getValue(l,a));p=s.getValue(l+i,"*");let d=s.getValue(l+2*i,"*"),y=Number(s.getValue(l+3*i,a)),m=[];for(let e=0;e<y;e++)m.push(Number(s.getValue(d+e*i,a)));0!==s._OrtFree(d)&&_("Can't free memory for tensor dims.");let h=m.reduce((e,t)=>e*t,1);f=P(o);let w=c?.outputPreferredLocations[n[t]];if("string"===f){if("gpu-buffer"===w||"ml-tensor"===w)throw Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<h;t++){let r=s.getValue(p+t*i,"*"),n=s.getValue(p+(t+1)*i,"*"),a=t===h-1?void 0:n-r;e.push(s.UTF8ToString(r,a))}E.push([f,m,e,"cpu"])}else if("gpu-buffer"===w&&h>0){let e=s.jsepGetBuffer;if(!e)throw Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let t=e(p),n=U(o,h);if(void 0===n||!N(f))throw Error(`Unsupported data type: ${f}`);u=!0,E.push([f,m,{gpuBuffer:t,download:s.jsepCreateDownloader(t,n,f),dispose:()=>{0!==s._OrtReleaseTensor(r)&&_("Can't release tensor.")}},"gpu-buffer"])}else if("ml-tensor"===w&&h>0){let t=s.webnnEnsureTensor,n=s.webnnIsGraphInputOutputTypeSupported;if(!t||!n)throw Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(void 0===U(o,h)||!k(f))throw Error(`Unsupported data type: ${f}`);if(!n(e,f,!1))throw Error(`preferredLocation "ml-tensor" for ${f} output is not supported by current WebNN Context.`);let a=await t(e,p,o,m,!1);u=!0,E.push([f,m,{mlTensor:a,download:s.webnnCreateMLTensorDownloader(p,f),dispose:()=>{s.webnnReleaseTensorId(p),s._OrtReleaseTensor(r)}},"ml-tensor"])}else if("ml-tensor-cpu-output"===w&&h>0){let e=s.webnnCreateMLTensorDownloader(p,f)(),t=E.length;u=!0,O.push((async()=>{let n=[t,await e];return s.webnnReleaseTensorId(p),s._OrtReleaseTensor(r),n})()),E.push([f,m,[],"cpu"])}else{let e=new(I(f))(h);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(s.HEAPU8.subarray(p,p+e.byteLength)),E.push([f,m,e,"cpu"])}}finally{s.stackRestore(o),"string"===f&&p&&s._free(p),u||s._OrtReleaseTensor(r)}}for(let[t,r]of(c&&!d&&(0!==s._OrtClearBoundOutputs(c.handle)&&_("Can't clear bound outputs."),K.set(e,[u,f,p,c,d,!1])),await Promise.all(O)))E[t][2]=r;return eP("wasm ProcessOutputTensor"),E}finally{s.webnnOnRunEnd?.(u),s.stackRestore(E),b.forEach(e=>s._OrtReleaseTensor(e)),g.forEach(e=>s._OrtReleaseTensor(e)),v.forEach(e=>s._free(e)),0!==h&&s._OrtReleaseRunOptions(h),w.forEach(e=>s._free(e))}},ea=e=>{let t=O(),r=K.get(e);if(!r)throw Error("invalid session id");let n=r[0],a=t._OrtEndProfiling(n);0===a&&_("Can't get an profile file name."),t._OrtFree(a)}}),es,ei,el,eu,ef,ep,ec,ed,ey,em,eh=W(()=>{"use strict";eo(),j(),G(),es=!1,ei=!1,el=!1,eu=async()=>{if(!ei){if(es)throw Error("multiple calls to 'initWasm()' detected.");if(el)throw Error("previous call to 'initWasm()' failed.");es=!0;try{await E(eU.wasm),await J(eU),ei=!0}catch(e){throw el=!0,e}finally{es=!1}}},ef=async e=>{await Y(eU,e)},ep=async e=>X(e),ec=async(e,t)=>ee(e,t),ed=async e=>{et(e)},ey=async(e,t,r,n,a,o)=>en(e,t,r,n,a,o),em=async e=>{ea(e)}}),ew,eb,eg,ev=W(()=>{"use strict";eh(),Z(),B(),q(),ew=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw Error(`invalid data location: ${e.location} for ${t()}`)}},eb=e=>{switch(e[3]){case"cpu":return new eI(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!N(t))throw Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:a}=e[2];return eI.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:a})}case"ml-tensor":{let t=e[0];if(!k(t))throw Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:a}=e[2];return eI.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:a})}default:throw Error(`invalid data location: ${e[3]}`)}},eg=class{async fetchModelAndCopyToWasmMemory(e){return ep(await F(e))}async loadModel(e,t){let r;e$(),r="string"==typeof e?i?await F(e):await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await ec(r,t),eN()}async dispose(){return ed(this.sessionId)}async run(e,t,r){e$();let n=[],a=[];Object.entries(e).forEach(e=>{let t=e[0],r=e[1],o=this.inputNames.indexOf(t);if(-1===o)throw Error(`invalid input '${t}'`);n.push(r),a.push(o)});let o=[],s=[];Object.entries(t).forEach(e=>{let t=e[0],r=e[1],n=this.outputNames.indexOf(t);if(-1===n)throw Error(`invalid output '${t}'`);o.push(r),s.push(n)});let i=n.map((e,t)=>ew(e,()=>`input "${this.inputNames[a[t]]}"`)),l=o.map((e,t)=>e?ew(e,()=>`output "${this.outputNames[s[t]]}"`):null),u=await ey(this.sessionId,a,i,s,l,r),f={};for(let e=0;e<u.length;e++)f[this.outputNames[s[e]]]=o[e]??eb(u[e]);return eN(),f}startProfiling(){}endProfiling(){em(this.sessionId)}}}),eE={},eO={OnnxruntimeWebAssemblyBackend:()=>e_,initializeFlags:()=>eC,wasmBackend:()=>eA};for(var eT in eO)n(eE,eT,{get:eO[eT],enumerable:!0});var eC,e_,eA,eR=W(()=>{"use strict";eh(),ev(),eC=()=>{("number"!=typeof ek.wasm.initTimeout||ek.wasm.initTimeout<0)&&(ek.wasm.initTimeout=0);let e=ek.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),ek.wasm.simd=!1),"boolean"!=typeof ek.wasm.proxy&&(ek.wasm.proxy=!1),"boolean"!=typeof ek.wasm.trace&&(ek.wasm.trace=!1),"number"!=typeof ek.wasm.numThreads||!Number.isInteger(ek.wasm.numThreads)||ek.wasm.numThreads<=0)if("u">typeof self&&!self.crossOriginIsolated)ek.wasm.numThreads=1;else{let e=typeof navigator>"u"?V("node:os").cpus().length:navigator.hardwareConcurrency;ek.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},eA=new(e_=class{async init(e){eC(),await eu(),await ef(e)}async createInferenceSessionHandler(e,t){let r=new eg;return await r.loadModel(e,t),r}})});export*from"onnxruntime-common";var ex=eL;{let e=(eR(),((e,t,r,i)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let l of o(t))s.call(e,l)||l===r||n(e,l,{get:()=>t[l],enumerable:!(i=a(t,l))||i.enumerable});return e})(n({},"__esModule",{value:!0}),eE)).wasmBackend;eM("cpu",e,10),eM("wasm",e,10)}Object.defineProperty(eF.versions,"web",{value:"1.23.2",enumerable:!0});import*as eL from"onnxruntime-common";import{TRACE_EVENT_BEGIN as eS,TRACE_EVENT_END as eP,env as eU,Tensor as eI,TRACE_FUNC_BEGIN as e$,TRACE_FUNC_END as eN,env as ek,registerBackend as eM,env as eF}from"onnxruntime-common";export{ex as default};