/*! For license information please see ort.webgpu.mjs.LICENSE.txt */
let e;var t,r,n,s,o,a,i,u,l,f,p,d,c,h,m,y,w,g,b,v,T,E,I,A,C,x,O,U,L,$,R,M,N,B,S,k,P,_,G,D,W,j,F,V,z,H,q,Z,X,Y,J,K,Q,ee,et,er,en,es,eo,ea,ei,eu,el,ef,ep,ed,ec,eh,em,ey,ew,eg,eb,ev,eT,eE,eI,eA,eC,ex,eO,eU,eL,e$,eR,eM,eN,eB,eS,ek,eP,e_,eG,eD,eW,ej,eF,eV,ez,eH,eq,eZ,eX,eY,eJ,eK,eQ,e0,e1,e2,e3,e4,e6,e8,e5,e9,e7,te,tt,tr,tn,ts,to,ta,ti=Object.defineProperty,tu=Object.getOwnPropertyDescriptor,tl=Object.getOwnPropertyNames,tf=Object.prototype.hasOwnProperty,tp=(e=function(e){if("undefined"!=typeof require)return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')},"undefined"!=typeof require?require:"undefined"!=typeof Proxy?new Proxy(e,{get:(e,t)=>("undefined"!=typeof require?require:e)[t]}):e),td=(e,t)=>function(){return e&&(t=(0,e[tl(e)[0]])(e=0)),t},tc=(e,t)=>{for(var r in t)ti(e,r,{get:t[r],enumerable:!0})},th=e=>((e,t,r,n)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let s of tl(t))tf.call(e,s)||s===r||ti(e,s,{get:()=>t[s],enumerable:!(n=tu(t,s))||n.enumerable});return e})(ti({},"__esModule",{value:!0}),e),tm=td({"common/dist/esm/backend-impl.js"(){"use strict";t=new Map,r=[],n=(e,n,s)=>{if(n&&"function"==typeof n.init&&"function"==typeof n.createInferenceSessionHandler){let o=t.get(e);if(void 0===o)t.set(e,{backend:n,priority:s});else if(o.priority>s)return;else if(o.priority===s&&o.backend!==n)throw Error(`cannot register backend "${e}" using priority ${s}`);if(s>=0){let n=r.indexOf(e);-1!==n&&r.splice(n,1);for(let n=0;n<r.length;n++)if(t.get(r[n]).priority<=s)return void r.splice(n,0,e);r.push(e)}return}throw TypeError("not a valid backend")},s=async e=>{let r=t.get(e);if(!r)return"backend not found.";if(r.initialized)return r.backend;{if(r.aborted)return r.error;let t=!!r.initPromise;try{return t||(r.initPromise=r.backend.init(e)),await r.initPromise,r.initialized=!0,r.backend}catch(e){return t||(r.error=`${e}`,r.aborted=!0),r.error}finally{delete r.initPromise}}},o=async e=>{let t,n=e.executionProviders||[],o=n.map(e=>"string"==typeof e?e:e.name),a=0===o.length?r:o,i=[],u=new Set;for(let e of a){let r=await s(e);"string"==typeof r?i.push({name:e,err:r}):(t||(t=r),t===r&&u.add(e))}if(!t)throw Error(`no available backend found. ERR: ${i.map(e=>`[${e.name}] ${e.err}`).join(", ")}`);for(let{name:e,err:t}of i)o.includes(e)&&console.warn(`removing requested execution provider "${e}" from session options because it is not available: ${t}`);let l=n.filter(e=>u.has("string"==typeof e?e:e.name));return[t,new Proxy(e,{get:(e,t)=>"executionProviders"===t?l:Reflect.get(e,t)})]}}}),ty=td({"common/dist/esm/backend.js"(){"use strict";tm()}}),tw=td({"common/dist/esm/version.js"(){"use strict";a="1.23.2"}}),tg=td({"common/dist/esm/env-impl.js"(){"use strict";tw(),i="warning",Object.defineProperty(u={wasm:{},webgl:{},webgpu:{},versions:{common:a},set logLevel(value){if(void 0===value)return;if("string"!=typeof value||-1===["verbose","info","warning","error","fatal"].indexOf(value))throw Error(`Unsupported logging level: ${value}`);i=value},get logLevel(){return i}},"logLevel",{enumerable:!0})}}),tb=td({"common/dist/esm/env.js"(){"use strict";tg(),l=u}}),tv=td({"common/dist/esm/tensor-conversion-impl.js"(){"use strict";f=(e,t)=>{let r="undefined"!=typeof document?document.createElement("canvas"):new OffscreenCanvas(1,1);r.width=e.dims[3],r.height=e.dims[2];let n=r.getContext("2d");if(null!=n){let s,o,a,i;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(s=e.dims[2],o=e.dims[3]):(s=e.dims[3],o=e.dims[2]);let u=t?.format!==void 0?t.format:"RGB",l=t?.norm;void 0===l||void 0===l.mean?a=[255,255,255,255]:"number"==typeof l.mean?a=[l.mean,l.mean,l.mean,l.mean]:(a=[l.mean[0],l.mean[1],l.mean[2],0],void 0!==l.mean[3]&&(a[3]=l.mean[3])),void 0===l||void 0===l.bias?i=[0,0,0,0]:"number"==typeof l.bias?i=[l.bias,l.bias,l.bias,l.bias]:(i=[l.bias[0],l.bias[1],l.bias[2],0],void 0!==l.bias[3]&&(i[3]=l.bias[3]));let f=o*s,p=0,d=f,c=2*f,h=-1;"RGBA"===u?(p=0,d=f,c=2*f,h=3*f):"RGB"===u?(p=0,d=f,c=2*f):"RBG"===u&&(p=0,c=f,d=2*f);for(let t=0;t<o;t++)for(let r=0;r<s;r++)n.fillStyle="rgba("+(e.data[p++]-i[0])*a[0]+","+(e.data[d++]-i[1])*a[1]+","+(e.data[c++]-i[2])*a[2]+","+(-1===h?255:(e.data[h++]-i[3])*a[3])+")",n.fillRect(r,t,1,1);if("toDataURL"in r)return r.toDataURL();throw Error("toDataURL is not supported")}throw Error("Can not access image data")},p=(e,t)=>{let r,n="undefined"!=typeof document?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d");if(null!=n){let s,o,a,i,u;t?.tensorLayout!==void 0&&"NHWC"===t.tensorLayout?(s=e.dims[2],o=e.dims[1],a=e.dims[3]):(s=e.dims[3],o=e.dims[2],a=e.dims[1]);let l=void 0!==t&&void 0!==t.format?t.format:"RGB",f=t?.norm;void 0===f||void 0===f.mean?i=[255,255,255,255]:"number"==typeof f.mean?i=[f.mean,f.mean,f.mean,f.mean]:(i=[f.mean[0],f.mean[1],f.mean[2],255],void 0!==f.mean[3]&&(i[3]=f.mean[3])),void 0===f||void 0===f.bias?u=[0,0,0,0]:"number"==typeof f.bias?u=[f.bias,f.bias,f.bias,f.bias]:(u=[f.bias[0],f.bias[1],f.bias[2],0],void 0!==f.bias[3]&&(u[3]=f.bias[3]));let p=o*s;if(void 0!==t&&(void 0!==t.format&&4===a&&"RGBA"!==t.format||3===a&&"RGB"!==t.format&&"BGR"!==t.format))throw Error("Tensor format doesn't match input tensor dims");let d=0,c=1,h=2,m=3,y=0,w=p,g=2*p,b=-1;"RGBA"===l?(y=0,w=p,g=2*p,b=3*p):"RGB"===l?(y=0,w=p,g=2*p):"RBG"===l&&(y=0,g=p,w=2*p),r=n.createImageData(s,o);for(let t=0;t<o*s;d+=4,c+=4,h+=4,m+=4,t++)r.data[d]=(e.data[y++]-u[0])*i[0],r.data[c]=(e.data[w++]-u[1])*i[1],r.data[h]=(e.data[g++]-u[2])*i[2],r.data[m]=-1===b?255:(e.data[b++]-u[3])*i[3]}else throw Error("Can not access image data");return r}}}),tT=td({"common/dist/esm/tensor-factory-impl.js"(){"use strict";tA(),d=(e,t)=>{let r,n;if(void 0===e)throw Error("Image buffer must be defined");if(void 0===t.height||void 0===t.width)throw Error("Image height and width must be defined");if("NHWC"===t.tensorLayout)throw Error("NHWC Tensor layout is not supported yet");let{height:s,width:o}=t,a=t.norm??{mean:255,bias:0};r="number"==typeof a.mean?[a.mean,a.mean,a.mean,a.mean]:[a.mean[0],a.mean[1],a.mean[2],a.mean[3]??255],n="number"==typeof a.bias?[a.bias,a.bias,a.bias,a.bias]:[a.bias[0],a.bias[1],a.bias[2],a.bias[3]??0];let i=void 0!==t.format?t.format:"RGBA",u=void 0!==t.tensorFormat&&void 0!==t.tensorFormat?t.tensorFormat:"RGB",l=s*o,f=new Float32Array("RGBA"===u?4*l:3*l),p=4,d=0,c=1,h=2,m=3,y=0,w=l,g=2*l,b=-1;"RGB"===i&&(p=3,d=0,c=1,h=2,m=-1),"RGBA"===u?b=3*l:"RBG"===u?(y=0,g=l,w=2*l):"BGR"===u&&(g=0,w=l,y=2*l);for(let t=0;t<l;t++,d+=p,h+=p,c+=p,m+=p)f[y++]=(e[d]+n[0])/r[0],f[w++]=(e[c]+n[1])/r[1],f[g++]=(e[h]+n[2])/r[2],-1!==b&&-1!==m&&(f[b++]=(e[m]+n[3])/r[3]);return"RGBA"===u?new A("float32",f,[1,4,s,o]):new A("float32",f,[1,3,s,o])},c=async(e,t)=>{let r,n="undefined"!=typeof HTMLImageElement&&e instanceof HTMLImageElement,s="undefined"!=typeof ImageData&&e instanceof ImageData,o="undefined"!=typeof ImageBitmap&&e instanceof ImageBitmap,a="string"==typeof e,i=t??{},u=()=>{if("undefined"!=typeof document)return document.createElement("canvas");if("undefined"!=typeof OffscreenCanvas)return new OffscreenCanvas(1,1);throw Error("Canvas is not supported")},l=e=>"undefined"!=typeof HTMLCanvasElement&&e instanceof HTMLCanvasElement||e instanceof OffscreenCanvas?e.getContext("2d"):null;if(n){let n=u();n.width=e.width,n.height=e.height;let s=l(n);if(null!=s){let n=e.height,o=e.width;if(void 0!==t&&void 0!==t.resizedHeight&&void 0!==t.resizedWidth&&(n=t.resizedHeight,o=t.resizedWidth),void 0!==t){if(i=t,void 0!==t.tensorFormat)throw Error("Image input config format must be RGBA for HTMLImageElement");i.tensorFormat="RGBA",i.height=n,i.width=o}else i.tensorFormat="RGBA",i.height=n,i.width=o;s.drawImage(e,0,0),r=s.getImageData(0,0,o,n).data}else throw Error("Can not access image data")}else if(s){let n,s;if(void 0!==t&&void 0!==t.resizedWidth&&void 0!==t.resizedHeight?(n=t.resizedHeight,s=t.resizedWidth):(n=e.height,s=e.width),void 0!==t&&(i=t),i.format="RGBA",i.height=n,i.width=s,void 0!==t){let t=u();t.width=s,t.height=n;let o=l(t);if(null!=o)o.putImageData(e,0,0),r=o.getImageData(0,0,s,n).data;else throw Error("Can not access image data")}else r=e.data}else if(o){if(void 0===t)throw Error("Please provide image config with format for Imagebitmap");let n=u();n.width=e.width,n.height=e.height;let s=l(n);if(null!=s){let t=e.height,n=e.width;return s.drawImage(e,0,0,n,t),r=s.getImageData(0,0,n,t).data,i.height=t,i.width=n,d(r,i)}throw Error("Can not access image data")}else if(a)return new Promise((t,r)=>{let n=u(),s=l(n);if(!e||!s)return r();let o=new Image;o.crossOrigin="Anonymous",o.src=e,o.onload=()=>{n.width=o.width,n.height=o.height,s.drawImage(o,0,0,n.width,n.height);let e=s.getImageData(0,0,n.width,n.height);i.height=n.height,i.width=n.width,t(d(e.data,i))}});else throw Error("Input data provided is not supported - aborted tensor creation");if(void 0!==r)return d(r,i);throw Error("Input data provided is not supported - aborted tensor creation")},h=(e,t)=>{let{width:r,height:n,download:s,dispose:o}=t;return new A({location:"texture",type:"float32",texture:e,dims:[1,n,r,4],download:s,dispose:o})},m=(e,t)=>{let{dataType:r,dims:n,download:s,dispose:o}=t;return new A({location:"gpu-buffer",type:r??"float32",gpuBuffer:e,dims:n,download:s,dispose:o})},y=(e,t)=>{let{dataType:r,dims:n,download:s,dispose:o}=t;return new A({location:"ml-tensor",type:r??"float32",mlTensor:e,dims:n,download:s,dispose:o})},w=(e,t,r)=>new A({location:"cpu-pinned",type:e,data:t,dims:r??[t.length]})}}),tE=td({"common/dist/esm/tensor-impl-type-mapping.js"(){"use strict";g=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),b=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),v=!1,T=()=>{if(!v){v=!0;let e="undefined"!=typeof BigInt64Array&&BigInt64Array.from,t="undefined"!=typeof BigUint64Array&&BigUint64Array.from,r=globalThis.Float16Array,n=void 0!==r&&r.from;e&&(g.set("int64",BigInt64Array),b.set(BigInt64Array,"int64")),t&&(g.set("uint64",BigUint64Array),b.set(BigUint64Array,"uint64")),n?(g.set("float16",r),b.set(r,"float16")):g.set("float16",Uint16Array)}}}}),tI=td({"common/dist/esm/tensor-utils-impl.js"(){"use strict";tA(),E=e=>{let t=1;for(let r=0;r<e.length;r++){let n=e[r];if("number"!=typeof n||!Number.isSafeInteger(n))throw TypeError(`dims[${r}] must be an integer, got: ${n}`);if(n<0)throw RangeError(`dims[${r}] must be a non-negative integer, got: ${n}`);t*=n}return t},I=(e,t)=>{switch(e.location){case"cpu":return new A(e.type,e.data,t);case"cpu-pinned":return new A({location:"cpu-pinned",data:e.data,type:e.type,dims:t});case"texture":return new A({location:"texture",texture:e.texture,type:e.type,dims:t});case"gpu-buffer":return new A({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:t});case"ml-tensor":return new A({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:t});default:throw Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}}),tA=td({"common/dist/esm/tensor-impl.js"(){"use strict";tv(),tT(),tE(),tI(),A=class{constructor(e,t,r){let n,s;if(T(),"object"==typeof e&&"location"in e)switch(this.dataLocation=e.location,n=e.type,s=e.dims,e.location){case"cpu-pinned":{let t=g.get(n);if(!t)throw TypeError(`unsupported type "${n}" to create tensor from pinned buffer`);if(!(e.data instanceof t))throw TypeError(`buffer should be of type ${t.name}`);this.cpuData=e.data;break}case"texture":if("float32"!==n)throw TypeError(`unsupported type "${n}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break;case"gpu-buffer":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw TypeError(`unsupported type "${n}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break;case"ml-tensor":if("float32"!==n&&"float16"!==n&&"int32"!==n&&"int64"!==n&&"uint32"!==n&&"uint64"!==n&&"int8"!==n&&"uint8"!==n&&"bool"!==n&&"uint4"!==n&&"int4"!==n)throw TypeError(`unsupported type "${n}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break;default:throw Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let o,a;if("string"==typeof e)if(n=e,a=r,"string"===e){if(!Array.isArray(t))throw TypeError("A string tensor's data must be a string array.");o=t}else{let r=g.get(e);if(void 0===r)throw TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(t))if("float16"===e&&r===Uint16Array||"uint4"===e||"int4"===e)throw TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${r.name} as data.`);else o="uint64"===e||"int64"===e?r.from(t,BigInt):r.from(t);else if(t instanceof r)o=t;else if(t instanceof Uint8ClampedArray)if("uint8"===e)o=Uint8Array.from(t);else throw TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else if("float16"===e&&t instanceof Uint16Array&&r!==Uint16Array)o=new globalThis.Float16Array(t.buffer,t.byteOffset,t.length);else throw TypeError(`A ${n} tensor's data must be type of ${r}`)}else if(a=t,Array.isArray(e)){if(0===e.length)throw TypeError("Tensor type cannot be inferred from an empty array.");let t=typeof e[0];if("string"===t)n="string",o=e;else if("boolean"===t)n="bool",o=Uint8Array.from(e);else throw TypeError(`Invalid element type of data array: ${t}.`)}else if(e instanceof Uint8ClampedArray)n="uint8",o=Uint8Array.from(e);else{let t=b.get(e.constructor);if(void 0===t)throw TypeError(`Unsupported type for tensor data: ${e.constructor}.`);n=t,o=e}if(void 0===a)a=[o.length];else if(!Array.isArray(a))throw TypeError("A tensor's dims must be a number array");s=a,this.cpuData=o,this.dataLocation="cpu"}let o=E(s);if(this.cpuData&&o!==this.cpuData.length)if(("uint4"===n||"int4"===n)&&Math.ceil(o/2)===this.cpuData.length);else throw Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=n,this.dims=s,this.size=o}static async fromImage(e,t){return c(e,t)}static fromTexture(e,t){return h(e,t)}static fromGpuBuffer(e,t){return m(e,t)}static fromMLTensor(e,t){return y(e,t)}static fromPinnedBuffer(e,t,r){return w(e,t,r)}toDataURL(e){return f(this,e)}toImageData(e){return p(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":if(!this.downloader)throw Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let t=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=t,e&&this.disposer&&(this.disposer(),this.disposer=void 0),t}finally{this.isDownloading=!1}default:throw Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if("none"===this.dataLocation)throw Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw Error("Cannot reshape a tensor that owns GPU resource.");return I(this,e)}}}}),tC=td({"common/dist/esm/tensor.js"(){"use strict";tA(),C=A}}),tx=td({"common/dist/esm/trace.js"(){"use strict";tg(),x=(e,t)=>{(void 0===u.trace?u.wasm.trace:u.trace)&&console.timeStamp(`${e}::ORT::${t}`)},O=(e,t)=>{let r=Error().stack?.split(/\r\n|\r|\n/g)||[],n=!1;for(let s=0;s<r.length;s++){if(n&&!r[s].includes("TRACE_FUNC")){let n=`FUNC_${e}::${r[s].trim().split(" ")[1]}`;t&&(n+=`::${t}`),x("CPU",n);return}r[s].includes("TRACE_FUNC")&&(n=!0)}},U=e=>{(void 0===u.trace?u.wasm.trace:u.trace)&&O("BEGIN",e)},L=e=>{(void 0===u.trace?u.wasm.trace:u.trace)&&O("END",e)},$=e=>{(void 0===u.trace?u.wasm.trace:u.trace)&&console.time(`ORT::${e}`)},R=e=>{(void 0===u.trace?u.wasm.trace:u.trace)&&console.timeEnd(`ORT::${e}`)}}}),tO=td({"common/dist/esm/inference-session-impl.js"(){"use strict";tm(),tC(),tx(),M=class e{constructor(e){this.handler=e}async run(e,t,r){U(),$("InferenceSession.run");let n={},s={};if("object"!=typeof e||null===e||e instanceof C||Array.isArray(e))throw TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let o=!0;if("object"==typeof t){if(null===t)throw TypeError("Unexpected argument[1]: cannot be null.");if(t instanceof C)throw TypeError("'fetches' cannot be a Tensor");if(Array.isArray(t)){if(0===t.length)throw TypeError("'fetches' cannot be an empty array.");for(let e of(o=!1,t)){if("string"!=typeof e)throw TypeError("'fetches' must be a string array or an object.");if(-1===this.outputNames.indexOf(e))throw RangeError(`'fetches' contains invalid output name: ${e}.`);n[e]=null}if("object"==typeof r&&null!==r)s=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else{let e=!1,a=Object.getOwnPropertyNames(t);for(let r of this.outputNames)if(-1!==a.indexOf(r)){let s=t[r];(null===s||s instanceof C)&&(e=!0,o=!1,n[r]=s)}if(e){if("object"==typeof r&&null!==r)s=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else s=t}}else if(void 0!==t)throw TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let t of this.inputNames)if(void 0===e[t])throw Error(`input '${t}' is missing in 'feeds'.`);if(o)for(let e of this.outputNames)n[e]=null;let a=await this.handler.run(e,n,s),i={};for(let e in a)if(Object.hasOwnProperty.call(a,e)){let t=a[e];t instanceof C?i[e]=t:i[e]=new C(t.type,t.data,t.dims)}return R("InferenceSession.run"),L(),i}async release(){return this.handler.dispose()}static async create(t,r,n,s){let a;U(),$("InferenceSession.create");let i={};if("string"==typeof t){if(a=t,"object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else if(t instanceof Uint8Array){if(a=t,"object"==typeof r&&null!==r)i=r;else if(void 0!==r)throw TypeError("'options' must be an object.")}else if(t instanceof ArrayBuffer||"undefined"!=typeof SharedArrayBuffer&&t instanceof SharedArrayBuffer){let e=0,o=t.byteLength;if("object"==typeof r&&null!==r)i=r;else if("number"==typeof r){if(!Number.isSafeInteger(e=r))throw RangeError("'byteOffset' must be an integer.");if(e<0||e>=t.byteLength)throw RangeError(`'byteOffset' is out of range [0, ${t.byteLength}).`);if(o=t.byteLength-e,"number"==typeof n){if(!Number.isSafeInteger(o=n))throw RangeError("'byteLength' must be an integer.");if(o<=0||e+o>t.byteLength)throw RangeError(`'byteLength' is out of range (0, ${t.byteLength-e}].`);if("object"==typeof s&&null!==s)i=s;else if(void 0!==s)throw TypeError("'options' must be an object.")}else if(void 0!==n)throw TypeError("'byteLength' must be a number.")}else if(void 0!==r)throw TypeError("'options' must be an object.");a=new Uint8Array(t,e,o)}else throw TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[u,l]=await o(i),f=await u.createInferenceSessionHandler(a,l);return R("InferenceSession.create"),L(),new e(f)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}get inputMetadata(){return this.handler.inputMetadata}get outputMetadata(){return this.handler.outputMetadata}}}}),tU=td({"common/dist/esm/inference-session.js"(){"use strict";tO(),N=M}}),tL=td({"common/dist/esm/tensor-conversion.js"(){}}),t$=td({"common/dist/esm/tensor-factory.js"(){}}),tR=td({"common/dist/esm/onnx-model.js"(){}}),tM=td({"common/dist/esm/onnx-value.js"(){}}),tN={};tc(tN,{InferenceSession:()=>N,TRACE:()=>x,TRACE_EVENT_BEGIN:()=>$,TRACE_EVENT_END:()=>R,TRACE_FUNC_BEGIN:()=>U,TRACE_FUNC_END:()=>L,Tensor:()=>C,env:()=>l,registerBackend:()=>n});var tB=td({"common/dist/esm/index.js"(){"use strict";ty(),tb(),tU(),tC(),tL(),t$(),tx(),tR(),tM()}}),tS=td({"web/lib/wasm/wasm-utils-env.ts"(){"use strict";B=!1}}),tk={};tc(tk,{default:()=>k});var tP=td({"web/lib/wasm/proxy-worker/main.ts"(){"use strict";tY(),tG(),t_(),(S=globalThis.self?.name==="ort-wasm-proxy-worker")&&(self.onmessage=e=>{let{type:t,in:r}=e.data;try{switch(t){case"init-wasm":K(r.wasm).then(()=>{ek(r).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})})},e=>{postMessage({type:t,err:e})});break;case"init-ep":{let{epName:e,env:n}=r;eP(n,e).then(()=>{postMessage({type:t})},e=>{postMessage({type:t,err:e})});break}case"copy-from":{let{buffer:e}=r,n=eD(e);postMessage({type:t,out:n});break}case"create":{let{model:e,options:n}=r;eW(e,n).then(e=>{postMessage({type:t,out:e})},e=>{postMessage({type:t,err:e})});break}case"release":ej(r),postMessage({type:t});break;case"run":{let{sessionId:e,inputIndices:n,inputs:s,outputIndices:o,options:a}=r;eV(e,n,s,o,Array(o.length).fill(null),a).then(e=>{e.some(e=>"cpu"!==e[3])?postMessage({type:t,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:t,out:e},eH([...s,...e]))},e=>{postMessage({type:t,err:e})});break}case"end-profiling":ez(r),postMessage({type:t})}}catch(e){postMessage({type:t,err:e})}}),k=S?null:e=>new Worker(e??G,{type:"module",name:"ort-wasm-proxy-worker"})}}),t_=td({"web/lib/wasm/wasm-utils-import.ts"(){"use strict";tS(),P=B||"undefined"==typeof location?void 0:location.origin,_=import.meta.url>"file:"&&import.meta.url<"file;",G=(()=>{if(!B){if(_){let e=URL;return new URL(new e("ort.webgpu.mjs",import.meta.url).href,P).href}return import.meta.url}})(),D=()=>{if(G&&!G.startsWith("blob:"))return G.substring(0,G.lastIndexOf("/")+1)},W=(e,t)=>{try{let r=t??G;return(r?new URL(e,r):new URL(e)).origin===P}catch{return!1}},j=async e=>{let t=await fetch(e,{credentials:"same-origin"}),r=await t.blob();return URL.createObjectURL(r)},F=async e=>(await import(e)).default,V=(tP(),th(tk)).default,z=async()=>{if(!G)throw Error("Failed to load proxy worker: cannot determine the script source URL.");if(W(G))return[void 0,V()];let e=await j(G);return[e,V(e)]},H=void 0,q=async(e,t,r,n)=>{let s=H&&!(e||t);if(s)if(G)s=W(G);else if(n&&!r)s=!0;else throw Error("cannot determine the script source URL.");if(s)return[void 0,H];{let n="ort-wasm-simd-threaded.asyncify.mjs",s=e??((e,t)=>{let r=t??G;try{return(r?new URL(e,r):new URL(e)).href}catch{return}})(n,t),o=!B&&r&&s&&!W(s,t),a=o?await j(s):s??`${t??"./"}${n}`;return[o?a:void 0,await F(a)]}}}}),tG=td({"web/lib/wasm/wasm-factory.ts"(){"use strict";t_(),X=!1,Y=!1,J=!1,K=async e=>{if(X)return Promise.resolve();if(Y)throw Error("multiple calls to 'initializeWebAssembly()' detected.");if(J)throw Error("previous call to 'initializeWebAssembly()' failed.");Y=!0;let t=e.initTimeout,r=e.numThreads;if(!1===e.simd);else if("relaxed"===e.simd){if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,5,1,96,0,1,123,3,2,1,0,10,19,1,17,0,65,1,253,15,65,2,253,15,65,3,253,15,253,147,2,11]))}catch(e){return!1}})())throw Error("Relaxed WebAssembly SIMD is not supported in the current environment.")}else if(!(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})())throw Error("WebAssembly SIMD is not supported in the current environment.");let n=(()=>{if("undefined"==typeof SharedArrayBuffer)return!1;try{return"undefined"!=typeof MessageChannel&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch(e){return!1}})();r>1&&!n&&("undefined"==typeof self||self.crossOriginIsolated||console.warn("env.wasm.numThreads is set to "+r+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=r=1);let s=e.wasmPaths,o="string"==typeof s?s:void 0,a=s?.mjs,i=a?.href??a,u=s?.wasm,l=u?.href??u,f=e.wasmBinary,[p,d]=await q(i,o,r>1,!!f||!!l),c=!1,h=[];if(t>0&&h.push(new Promise(e=>{setTimeout(()=>{c=!0,e()},t)})),h.push(new Promise((e,t)=>{let n={numThreads:r};if(f)n.wasmBinary=f;else if(l||o)n.locateFile=e=>l??o+e;else if(i&&0!==i.indexOf("blob:"))n.locateFile=e=>new URL(e,i).href;else if(p){let e=D();e&&(n.locateFile=t=>e+t)}d(n).then(t=>{Y=!1,X=!0,Z=t,e(),p&&URL.revokeObjectURL(p)},e=>{Y=!1,J=!0,t(e)})})),await Promise.race(h),c)throw Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},Q=()=>{if(X&&Z)return Z;throw Error("WebAssembly is not initialized yet.")}}}),tD=td({"web/lib/wasm/wasm-utils.ts"(){"use strict";tG(),ee=(e,t)=>{let r=Q(),n=r.lengthBytesUTF8(e)+1,s=r._malloc(n);return r.stringToUTF8(e,s,n),t.push(s),s},et=(e,t,r,n)=>{if("object"==typeof e&&null!==e)if(r.has(e))throw Error("Circular reference in options");else r.add(e);Object.entries(e).forEach(([e,s])=>{let o=t?t+e:e;if("object"==typeof s)et(s,o+".",r,n);else if("string"==typeof s||"number"==typeof s)n(o,s.toString());else if("boolean"==typeof s)n(o,s?"1":"0");else throw Error(`Can't handle extra config type: ${typeof s}`)})},er=e=>{let t=Q(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r);t._OrtGetLastError(n,n+r);let s=Number(t.getValue(n,4===r?"i32":"i64")),o=t.getValue(n+r,"*"),a=o?t.UTF8ToString(o):"";throw Error(`${e} ERROR_CODE: ${s}, ERROR_MESSAGE: ${a}`)}finally{t.stackRestore(r)}}}}),tW=td({"web/lib/wasm/run-options.ts"(){"use strict";tG(),tD(),en=e=>{let t=Q(),r=0,n=[],s=e||{};try{if(e?.logSeverityLevel===void 0)s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw Error(`log severity level is not valid: ${e.logSeverityLevel}`);if(e?.logVerbosityLevel===void 0)s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);e?.terminate===void 0&&(s.terminate=!1);let o=0;return e?.tag!==void 0&&(o=ee(e.tag,n)),r=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===r&&er("Can't create run options."),e?.extra!==void 0&&et(e.extra,"",new WeakSet,(e,s)=>{let o=ee(e,n),a=ee(s,n);0!==t._OrtAddRunConfigEntry(r,o,a)&&er(`Can't set a run config entry: ${e} - ${s}.`)}),[r,n]}catch(e){throw 0!==r&&t._OrtReleaseRunOptions(r),n.forEach(e=>t._free(e)),e}}}}),tj=td({"web/lib/wasm/session-options.ts"(){"use strict";tG(),tD(),es=(e,t,r,n)=>{let s=ee(t,n),o=ee(r,n);0!==Q()._OrtAddSessionConfigEntry(e,s,o)&&er(`Can't set a session config entry: ${t} - ${r}.`)},eo=(e,t,r,n)=>{let s=ee(t,n),o=ee(r,n);e.push([s,o])},ea=async(e,t,r)=>{for(let n of t){let t="string"==typeof n?n:n.name,s=[];switch(t){case"webnn":if(t="WEBNN","string"!=typeof n){let t=n?.deviceType;t&&es(e,"deviceType",t,r)}break;case"webgpu":{let e;if(t="WebGPU","string"!=typeof n&&n.device)if("undefined"!=typeof GPUDevice&&n.device instanceof GPUDevice)e=n.device;else throw Error("Invalid GPU device set in WebGPU EP options.");let o=Q().webgpuRegisterDevice(e);if(o){let[e,t,n]=o;eo(s,"deviceId",e.toString(),r),eo(s,"webgpuInstance",t.toString(),r),eo(s,"webgpuDevice",n.toString(),r)}}break;case"wasm":case"cpu":continue;default:throw Error(`not supported execution provider: ${t}`)}let o=ee(t,r),a=s.length,i=0,u=0;if(a>0){i=Q()._malloc(a*Q().PTR_SIZE),r.push(i),u=Q()._malloc(a*Q().PTR_SIZE),r.push(u);for(let e=0;e<a;e++)Q().setValue(i+e*Q().PTR_SIZE,s[e][0],"*"),Q().setValue(u+e*Q().PTR_SIZE,s[e][1],"*")}await Q()._OrtAppendExecutionProvider(e,o,i,u,a)!==0&&er(`Can't append execution provider: ${t}.`)}},ei=async e=>{let t,r=Q(),n=0,s=[],o=e||{};o.extra||(o.extra={}),o.extra.session||(o.extra.session={}),(t=o.extra.session).use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),o.executionProviders&&o.executionProviders.some(e=>("string"==typeof e?e:e.name)==="webgpu")&&(o.enableMemPattern=!1);try{let e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"layout":return 3;case"all":return 99;default:throw Error(`unsupported graph optimization level: ${e}`)}})(o.graphOptimizationLevel??"all"),t=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw Error(`unsupported execution mode: ${e}`)}})(o.executionMode??"sequential"),a="string"==typeof o.logId?ee(o.logId,s):0,i=o.logSeverityLevel??2;if(!Number.isInteger(i)||i<0||i>4)throw Error(`log severity level is not valid: ${i}`);let u=o.logVerbosityLevel??0;if(!Number.isInteger(u)||u<0||u>4)throw Error(`log verbosity level is not valid: ${u}`);let l="string"==typeof o.optimizedModelFilePath?ee(o.optimizedModelFilePath,s):0;if(n=r._OrtCreateSessionOptions(e,!!o.enableCpuMemArena,!!o.enableMemPattern,t,!!o.enableProfiling,0,a,i,u,l),0===n&&er("Can't create session options."),o.executionProviders&&await ea(n,o.executionProviders,s),void 0!==o.enableGraphCapture){if("boolean"!=typeof o.enableGraphCapture)throw Error(`enableGraphCapture must be a boolean value: ${o.enableGraphCapture}`);es(n,"enableGraphCapture",o.enableGraphCapture.toString(),s)}if(o.freeDimensionOverrides)for(let[e,t]of Object.entries(o.freeDimensionOverrides)){if("string"!=typeof e)throw Error(`free dimension override name must be a string: ${e}`);if("number"!=typeof t||!Number.isInteger(t)||t<0)throw Error(`free dimension override value must be a non-negative integer: ${t}`);let o=ee(e,s);0!==r._OrtAddFreeDimensionOverride(n,o,t)&&er(`Can't set a free dimension override: ${e} - ${t}.`)}return void 0!==o.extra&&et(o.extra,"",new WeakSet,(e,t)=>{es(n,e,t,s)}),[n,s]}catch(e){throw 0!==n&&0!==r._OrtReleaseSessionOptions(n)&&er("Can't release session options."),s.forEach(e=>r._free(e)),e}}}}),tF=td({"web/lib/wasm/wasm-common.ts"(){"use strict";eu=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw Error(`unsupported data type: ${e}`)}},el=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw Error(`unsupported data type: ${e}`)}},ef=(e,t)=>{let r=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],n="number"==typeof t?t:t.reduce((e,t)=>e*t,1);return r>0?Math.ceil(n*r):void 0},ep=e=>{switch(e){case"float16":return"undefined"!=typeof Float16Array&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw Error(`unsupported type: ${e}`)}},ed=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw Error(`unsupported logging level: ${e}`)}},ec=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,eh=e=>"float32"===e||"float16"===e||"int32"===e||"int64"===e||"uint32"===e||"uint64"===e||"int8"===e||"uint8"===e||"bool"===e||"uint4"===e||"int4"===e,em=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw Error(`unsupported data location: ${e}`)}}}}),tV=td({"web/lib/wasm/wasm-utils-load-file.ts"(){"use strict";tS(),ey=async e=>{if("string"==typeof e)if(B)try{let{readFile:t}=tp("node:fs/promises");return new Uint8Array(await t(e))}catch(t){if("ERR_FS_FILE_TOO_LARGE"===t.code){let{createReadStream:t}=tp("node:fs"),r=t(e),n=[];for await(let e of r)n.push(e);return new Uint8Array(Buffer.concat(n))}throw t}else{let t=await fetch(e);if(!t.ok)throw Error(`failed to load external data file: ${e}`);let r=t.headers.get("Content-Length"),n=r?parseInt(r,10):0;if(n<0x40000000)return new Uint8Array(await t.arrayBuffer());{let r;if(!t.body)throw Error(`failed to load external data file: ${e}, no response body.`);let s=t.body.getReader();try{r=new ArrayBuffer(n)}catch(e){if(e instanceof RangeError){let e=Math.ceil(n/65536);r=new WebAssembly.Memory({initial:e,maximum:e}).buffer}else throw e}let o=0;for(;;){let{done:e,value:t}=await s.read();if(e)break;let n=t.byteLength;new Uint8Array(r,o,n).set(t),o+=n}return new Uint8Array(r,0,n)}}return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}}),tz=td({"web/lib/wasm/jsep/tensor-view.ts"(){"use strict";tF(),ew=(e,t)=>new(ep(t))(e)}}),tH=td({"web/lib/wasm/jsep/log.ts"(){"use strict";tF(),eg=["V","I","W","E","F"],eT=(e,t)=>{eb=e,ev=t},eE=(...e)=>{ev&&((e,t)=>{var r;let n=ed(e);n>=ed(eb)&&(r="function"==typeof t?t():t,console.log(`[${eg[n]},${new Date().toISOString()}]${r}`))})(...e)}}}),tq=td({"web/lib/wasm/jsep/webnn/tensor-manager.ts"(){"use strict";tF(),tH(),eI=new Map([["float32",32],["float16",16],["int32",32],["uint32",32],["int64",64],["uint64",64],["int8",8],["uint8",8],["int4",4],["uint4",4]]),eA=(e,t)=>{if("int32"===t)return e;let r=eI.get(t);if(!r)throw Error(`WebNN backend does not support data type: ${t}`);let n=r/8;if(e.byteLength%n!=0)throw Error(`Invalid Uint8Array length - must be a multiple of ${n}.`);let s=e.byteLength/n,o=new(ep(t))(e.buffer,e.byteOffset,s);switch(t){case"int64":case"uint64":{let e=new Int32Array(s);for(let t=0;t<s;t++){let r=o[t];if(r>2147483647n||r<-2147483648n)throw Error("Can not convert int64 data to int32 - value out of range.");e[t]=Number(r)}return new Uint8Array(e.buffer)}case"int8":case"uint8":case"uint32":if("uint32"===t&&o.some(e=>e>0x7fffffff))throw Error("Can not convert uint32 data to int32 - value out of range.");return new Uint8Array(Int32Array.from(o,Number).buffer);default:throw Error(`Unsupported data conversion from ${t} to 'int32'`)}},eC=(e,t)=>{if("int32"===t)return e;if(e.byteLength%4!=0)throw Error("Invalid Uint8Array length - must be a multiple of 4 (int32).");let r=e.byteLength/4,n=new Int32Array(e.buffer,e.byteOffset,r);switch(t){case"int64":return new Uint8Array(BigInt64Array.from(n,BigInt).buffer);case"uint64":if(n.some(e=>e<0))throw Error("Can not convert int32 data to uin64 - negative value found.");return new Uint8Array(BigUint64Array.from(n,BigInt).buffer);case"int8":if(n.some(e=>e<-128||e>127))throw Error("Can not convert int32 data to int8 - value out of range.");return new Uint8Array(Int8Array.from(n,Number).buffer);case"uint8":if(n.some(e=>e<0||e>255))throw Error("Can not convert int32 data to uint8 - value out of range.");return Uint8Array.from(n,Number);case"uint32":if(n.some(e=>e<0))throw Error("Can not convert int32 data to uint32 - negative value found.");return new Uint8Array(Uint32Array.from(n,Number).buffer);default:throw Error(`Unsupported data conversion from 'int32' to ${t}`)}},ex=1,eO=()=>ex++,eU=new Map([["int8","int32"],["uint8","int32"],["uint32","int32"],["int64","int32"]]),eL=(e,t)=>{let r=eI.get(e);if(!r)throw Error(`WebNN backend does not support data type: ${e}`);return t.length>0?Math.ceil(t.reduce((e,t)=>e*t)*r/8):0},e$=class{constructor(e){this.isDataConverted=!1;let{sessionId:t,context:r,tensor:n,dataType:s,shape:o,fallbackDataType:a}=e;this.sessionId=t,this.mlContext=r,this.mlTensor=n,this.dataType=s,this.tensorShape=o,this.fallbackDataType=a}get tensor(){return this.mlTensor}get type(){return this.dataType}get fallbackType(){return this.fallbackDataType}get shape(){return this.tensorShape}get byteLength(){return eL(this.dataType,this.tensorShape)}destroy(){eE("verbose",()=>"[WebNN] TensorWrapper.destroy"),this.mlTensor.destroy()}write(e){this.mlContext.writeTensor(this.mlTensor,e)}async read(e){if(!this.fallbackDataType)return e?this.mlContext.readTensor(this.mlTensor,e):this.mlContext.readTensor(this.mlTensor);{let t=eC(new Uint8Array(await this.mlContext.readTensor(this.mlTensor)),this.dataType);return e?void(e instanceof ArrayBuffer?new Uint8Array(e):new Uint8Array(e.buffer,e.byteOffset,e.byteLength)).set(t):t.buffer}}canReuseTensor(e,t,r){return this.mlContext===e&&this.dataType===t&&this.tensorShape.length===r.length&&this.tensorShape.every((e,t)=>e===r[t])}setIsDataConverted(e){this.isDataConverted=e}},eR=class{constructor(e,t){this.tensorManager=e,this.wrapper=t}get tensorWrapper(){return this.wrapper}releaseTensor(){this.tensorWrapper&&(this.tensorManager.releaseTensor(this.tensorWrapper),this.wrapper=void 0)}async ensureTensor(e,t,r,n){let s,o=this.tensorManager.getMLContext(e);if(!o.opSupportLimits().input.dataTypes.includes(t)){if(!(s=eU.get(t))||!o.opSupportLimits().input.dataTypes.includes(s))throw Error(`WebNN backend does not support data type: ${t}`);eE("verbose",()=>`[WebNN] TensorIdTracker.ensureTensor: fallback dataType from ${t} to ${s}`)}if(this.wrapper)if(this.wrapper.canReuseTensor(o,t,r))return this.wrapper.tensor;else{if(n){if(this.wrapper.byteLength!==eL(t,r))throw Error("Unable to copy data to tensor with different size.");this.activeUpload=new Uint8Array(await this.wrapper.read())}this.tensorManager.releaseTensor(this.wrapper)}let a="undefined"==typeof MLTensorUsage?void 0:MLTensorUsage.READ|MLTensorUsage.WRITE;return this.wrapper=await this.tensorManager.getCachedTensor(e,t,r,a,!0,!0,s),n&&this.activeUpload&&(this.wrapper.write(this.activeUpload),this.activeUpload=void 0),this.wrapper.tensor}upload(e){let t=e;if(this.wrapper){if(this.wrapper.fallbackType)if("int32"===this.wrapper.fallbackType)t=eA(e,this.wrapper.type),this.wrapper.setIsDataConverted(!0);else throw Error(`Unsupported fallback data type: ${this.wrapper.fallbackType}`);if(e.byteLength===this.wrapper.byteLength)return void this.wrapper.write(t);eE("verbose",()=>"Data size does not match tensor size. Releasing tensor."),this.releaseTensor()}this.activeUpload?this.activeUpload.set(t):this.activeUpload=new Uint8Array(t)}async download(e){if(this.activeUpload){let t=this.wrapper?.isDataConverted?eC(this.activeUpload,this.wrapper?.type):this.activeUpload;return e?void(e instanceof ArrayBuffer?new Uint8Array(e).set(t):new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(t)):t.buffer}if(!this.wrapper)throw Error("Tensor has not been created.");return e?this.wrapper.read(e):this.wrapper.read()}},eM=class{constructor(e){this.backend=e,this.tensorTrackersById=new Map,this.freeTensors=[],this.externalTensors=new Set}getMLContext(e){let t=this.backend.getMLContext(e);if(!t)throw Error("MLContext not found for session.");return t}reserveTensorId(){let e=eO();return this.tensorTrackersById.set(e,new eR(this)),e}releaseTensorId(e){let t=this.tensorTrackersById.get(e);t&&(this.tensorTrackersById.delete(e),t.tensorWrapper&&this.releaseTensor(t.tensorWrapper))}async ensureTensor(e,t,r,n,s){eE("verbose",()=>`[WebNN] TensorManager.ensureTensor {tensorId: ${t}, dataType: ${r}, shape: ${n}, copyOld: ${s}}`);let o=this.tensorTrackersById.get(t);if(!o)throw Error("Tensor not found.");return o.ensureTensor(e,r,n,s)}upload(e,t){let r=this.tensorTrackersById.get(e);if(!r)throw Error("Tensor not found.");r.upload(t)}async download(e,t){eE("verbose",()=>`[WebNN] TensorManager.download {tensorId: ${e}, dstBuffer: ${t?.byteLength}}`);let r=this.tensorTrackersById.get(e);if(!r)throw Error("Tensor not found.");return r.download(t)}releaseTensorsForSession(e){for(let t of this.freeTensors)t.sessionId===e&&t.destroy();this.freeTensors=this.freeTensors.filter(t=>t.sessionId!==e)}registerTensor(e,t,r,n){let s=this.getMLContext(e),o=eO(),a=new e$({sessionId:e,context:s,tensor:t,dataType:r,shape:n});return this.tensorTrackersById.set(o,new eR(this,a)),this.externalTensors.add(a),o}async getCachedTensor(e,t,r,n,s,o,a){let i=this.getMLContext(e);for(let[n,s]of this.freeTensors.entries())if(s.canReuseTensor(i,t,r)){eE("verbose",()=>`[WebNN] Reusing tensor {dataType: ${t}, ${a?`fallbackDataType: ${a},`:""} shape: ${r}`);let s=this.freeTensors.splice(n,1)[0];return s.sessionId=e,s}eE("verbose",()=>`[WebNN] MLContext.createTensor {dataType: ${t}, ${a?`fallbackDataType: ${a},`:""} shape: ${r}}`);let u=await i.createTensor({dataType:a??t,shape:r,dimensions:r,usage:n,writable:s,readable:o});return new e$({sessionId:e,context:i,tensor:u,dataType:t,shape:r,fallbackDataType:a})}releaseTensor(e){this.externalTensors.has(e)&&this.externalTensors.delete(e),this.freeTensors.push(e)}},eN=(...e)=>new eM(...e)}}),tZ={};tc(tZ,{WebNNBackend:()=>eS});var tX=td({"web/lib/wasm/jsep/backend-webnn.ts"(){"use strict";tF(),tG(),tz(),tq(),tH(),eB=new Map([[1,"float32"],[10,"float16"],[6,"int32"],[12,"uint32"],[7,"int64"],[13,"uint64"],[22,"int4"],[21,"uint4"],[3,"int8"],[2,"uint8"],[9,"uint8"]]),eS=class{constructor(e){this.tensorManager=eN(this),this.mlContextBySessionId=new Map,this.sessionIdsByMLContext=new Map,this.mlContextCache=[],this.sessionGraphInputs=new Map,this.sessionGraphOutputs=new Map,this.temporaryGraphInputs=[],this.temporaryGraphOutputs=[],this.temporarySessionTensorIds=new Map,eT(e.logLevel,!!e.debug)}get currentSessionId(){if(void 0===this.activeSessionId)throw Error("No active session");return this.activeSessionId}onRunStart(e){eE("verbose",()=>`[WebNN] onRunStart {sessionId: ${e}}`),this.activeSessionId=e}onRunEnd(e){eE("verbose",()=>`[WebNN] onRunEnd {sessionId: ${e}}`);let t=this.temporarySessionTensorIds.get(e);if(t){for(let e of t)eE("verbose",()=>`[WebNN] releasing temporary tensor {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e);this.temporarySessionTensorIds.delete(e),this.activeSessionId=void 0}}async createMLContext(e){if(e instanceof GPUDevice){let t=this.mlContextCache.findIndex(t=>t.gpuDevice===e);if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({gpuDevice:e,mlContext:t}),t}}if(void 0===e){let e=this.mlContextCache.findIndex(e=>void 0===e.options&&void 0===e.gpuDevice);if(-1!==e)return this.mlContextCache[e].mlContext;{let e=await navigator.ml.createContext();return this.mlContextCache.push({mlContext:e}),e}}let t=this.mlContextCache.findIndex(t=>((e,t)=>{if(e===t)return!0;if(void 0===e||void 0===t)return!1;let r=Object.keys(e).sort(),n=Object.keys(t).sort();return r.length===n.length&&r.every((r,s)=>r===n[s]&&e[r]===t[r])})(t.options,e));if(-1!==t)return this.mlContextCache[t].mlContext;{let t=await navigator.ml.createContext(e);return this.mlContextCache.push({options:e,mlContext:t}),t}}registerMLContext(e,t){this.mlContextBySessionId.set(e,t);let r=this.sessionIdsByMLContext.get(t);r||(r=new Set,this.sessionIdsByMLContext.set(t,r)),r.add(e),this.temporaryGraphInputs.length>0&&(this.sessionGraphInputs.set(e,this.temporaryGraphInputs),this.temporaryGraphInputs=[]),this.temporaryGraphOutputs.length>0&&(this.sessionGraphOutputs.set(e,this.temporaryGraphOutputs),this.temporaryGraphOutputs=[])}onReleaseSession(e){this.sessionGraphInputs.delete(e),this.sessionGraphOutputs.delete(e);let t=this.mlContextBySessionId.get(e);if(!t)return;this.tensorManager.releaseTensorsForSession(e),this.mlContextBySessionId.delete(e);let r=this.sessionIdsByMLContext.get(t);if(r.delete(e),0===r.size){this.sessionIdsByMLContext.delete(t);let e=this.mlContextCache.findIndex(e=>e.mlContext===t);-1!==e&&this.mlContextCache.splice(e,1)}}getMLContext(e){return this.mlContextBySessionId.get(e)}reserveTensorId(){return this.tensorManager.reserveTensorId()}releaseTensorId(e){eE("verbose",()=>`[WebNN] releaseTensorId {tensorId: ${e}}`),this.tensorManager.releaseTensorId(e)}async ensureTensor(e,t,r,n,s){let o=eB.get(r);if(!o)throw Error(`Unsupported ONNX data type: ${r}`);return this.tensorManager.ensureTensor(e??this.currentSessionId,t,o,n,s)}async createTemporaryTensor(e,t,r){eE("verbose",()=>`[WebNN] createTemporaryTensor {onnxDataType: ${t}, shape: ${r}}`);let n=eB.get(t);if(!n)throw Error(`Unsupported ONNX data type: ${t}`);let s=this.tensorManager.reserveTensorId();await this.tensorManager.ensureTensor(e,s,n,r,!1);let o=this.temporarySessionTensorIds.get(e);return o?o.push(s):this.temporarySessionTensorIds.set(e,[s]),s}uploadTensor(e,t){if(!Q().shouldTransferToMLTensor)throw Error("Trying to upload to a MLTensor while shouldTransferToMLTensor is false");eE("verbose",()=>`[WebNN] uploadTensor {tensorId: ${e}, data: ${t.byteLength}}`),this.tensorManager.upload(e,t)}async downloadTensor(e,t){return this.tensorManager.download(e,t)}createMLTensorDownloader(e,t){return async()=>{let r=await this.tensorManager.download(e);return ew(r,t)}}registerMLTensor(e,t,r,n){let s=eB.get(r);if(!s)throw Error(`Unsupported ONNX data type: ${r}`);let o=this.tensorManager.registerTensor(e,t,s,n);return eE("verbose",()=>`[WebNN] registerMLTensor {tensor: ${t}, dataType: ${s}, dimensions: ${n}} -> {tensorId: ${o}}`),o}registerMLConstant(e,t,r,n,s,o,a=!1){let i;if(!o)throw Error("External mounted files are not available.");let u=e;e.startsWith("./")&&(u=e.substring(2));let l=o.get(u);if(!l)throw Error(`File with name ${u} not found in preloaded files.`);if(t+r>l.byteLength)throw Error("Out of bounds: data offset and length exceed the external file data size.");let f=l.slice(t,t+r).buffer;switch(s.dataType){case"float32":i=new Float32Array(f);break;case"float16":i="undefined"!=typeof Float16Array&&Float16Array.from?new Float16Array(f):new Uint16Array(f);break;case"int32":i=new Int32Array(f);break;case"uint32":i=new Uint32Array(f);break;case"int64":a?(i=new Int32Array(eA(new Uint8Array(f),"int64").buffer),s.dataType="int32"):i=new BigInt64Array(f);break;case"uint64":i=new BigUint64Array(f);break;case"int8":i=new Int8Array(f);break;case"int4":case"uint4":case"uint8":i=new Uint8Array(f);break;default:throw Error(`Unsupported data type: ${s.dataType} in creating WebNN Constant from external data.`)}return eE("verbose",()=>`[WebNN] registerMLConstant {dataType: ${s.dataType}, shape: ${s.shape}}} ${a?"(Note: it was int64 data type and registered to int32 as workaround)":""}`),n.constant(s,i)}registerGraphInput(e){this.temporaryGraphInputs.push(e)}registerGraphOutput(e){this.temporaryGraphOutputs.push(e)}isGraphInput(e,t){let r=this.sessionGraphInputs.get(e);return!!r&&r.includes(t)}isGraphOutput(e,t){let r=this.sessionGraphOutputs.get(e);return!!r&&r.includes(t)}isGraphInputOutputTypeSupported(e,t,r=!0){let n=this.mlContextBySessionId.get(e),s=eB.get(eu(t));return void 0!==s&&(r?!!n?.opSupportLimits().input.dataTypes.includes(s):!!n?.opSupportLimits().output.dataTypes.includes(s))}flush(){}}}}),tY=td({"web/lib/wasm/wasm-core-impl.ts"(){"use strict";tB(),tW(),tj(),tF(),tG(),tD(),tV(),ek=async e=>{var t,r;t=e.wasm.numThreads,r=ed(e.logLevel),0!==Q()._OrtInit(t,r)&&er("Can't initialize onnxruntime.")},eP=async(e,t)=>{Q().asyncInit?.();let r=e.webgpu.adapter;if("webgpu"===t){if("undefined"==typeof navigator||!navigator.gpu)throw Error("WebGPU is not supported in current environment");if(r){if("object"!=typeof r.limits||"object"!=typeof r.features||"function"!=typeof r.requestDevice)throw Error("Invalid GPU adapter set in `env.webgpu.adapter`. It must be a GPUAdapter object.")}else{let t=e.webgpu.powerPreference;if(void 0!==t&&"low-power"!==t&&"high-performance"!==t)throw Error(`Invalid powerPreference setting: "${t}"`);let n=e.webgpu.forceFallbackAdapter;if(void 0!==n&&"boolean"!=typeof n)throw Error(`Invalid forceFallbackAdapter setting: "${n}"`);if(!(r=await navigator.gpu.requestAdapter({powerPreference:t,forceFallbackAdapter:n})))throw Error('Failed to get GPU adapter. You may need to enable flag "--enable-unsafe-webgpu" if you are using Chrome.')}}if("webnn"===t&&("undefined"==typeof navigator||!navigator.ml))throw Error("WebNN is not supported in current environment");if("webgpu"===t&&Q().webgpuInit(t=>{e.webgpu.device=t}),"webnn"===t){let t=new(tX(),th(tZ)).WebNNBackend(e);Q().webnnInit([t,()=>t.reserveTensorId(),e=>t.releaseTensorId(e),async(e,r,n,s,o)=>t.ensureTensor(e,r,n,s,o),(e,r)=>{t.uploadTensor(e,r)},async(e,r)=>t.downloadTensor(e,r),(e,r)=>t.registerMLContext(e,r),!!e.trace])}},e_=new Map,eG=(e,t)=>{let r=Q(),n=r.stackSave(),s=0;try{let n=r.PTR_SIZE,o=r.stackAlloc(2*n),a=r._OrtGetInputOutputMetadata(e,t,o,o+n);0!==a&&er("Can't get session input/output metadata.");let i=Number(r.getValue(o,"*"));s=Number(r.getValue(o+n,"*"));let u=r.HEAP32[s/4];if(0===u)return[i,0];let l=r.HEAPU32[s/4+1],f=[];for(let e=0;e<l;e++){let t=Number(r.getValue(s+8+e*n,"*"));f.push(0!==t?r.UTF8ToString(t):Number(r.getValue(s+8+(e+l)*n,"*")))}return[i,u,f]}finally{r.stackRestore(n),0!==s&&r._OrtFree(s)}},eD=e=>{let t=Q(),r=t._malloc(e.byteLength);if(0===r)throw Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return t.HEAPU8.set(e,r),[r,e.byteLength]},eW=async(e,t)=>{let r,n,s=Q();Array.isArray(e)?[r,n]=e:e.buffer===s.HEAPU8.buffer?[r,n]=[e.byteOffset,e.byteLength]:[r,n]=eD(e);let o=0,a=0,i=0,u=[],l=[],f=[];try{if([a,u]=await ei(t),t?.externalData&&s.mountExternalData){let e=[];for(let r of t.externalData){let t="string"==typeof r?r:r.path;e.push(ey("string"==typeof r?r:r.data).then(e=>{s.mountExternalData(t,e)}))}await Promise.all(e)}for(let e of t?.executionProviders??[]){let t="string"==typeof e?e:e.name;if("webnn"===t){if(s.shouldTransferToMLTensor=!1,"string"!=typeof e){let t=e?.context,r=e?.gpuDevice,n=e?.deviceType,o=e?.powerPreference;t?s.currentContext=t:r?s.currentContext=await s.webnnCreateMLContext(r):s.currentContext=await s.webnnCreateMLContext({deviceType:n,powerPreference:o})}else s.currentContext=await s.webnnCreateMLContext();break}}o=await s._OrtCreateSession(r,n,a),s.webgpuOnCreateSession?.(o),0===o&&er("Can't create a session."),s.jsepOnCreateSession?.(),s.currentContext&&(s.webnnRegisterMLContext(o,s.currentContext),s.currentContext=void 0,s.shouldTransferToMLTensor=!0);let[e,p]=(e=>{let t=Q(),r=t.stackSave();try{let r=t.PTR_SIZE,n=t.stackAlloc(2*r),s=t._OrtGetInputOutputCount(e,n,n+r);0!==s&&er("Can't get session input/output count.");let o=4===r?"i32":"i64";return[Number(t.getValue(n,o)),Number(t.getValue(n+r,o))]}finally{t.stackRestore(r)}})(o),d=!!t?.enableGraphCapture,c=[],h=[],m=[],y=[],w=[];for(let t=0;t<e;t++){let[e,r,n]=eG(o,t);0===e&&er("Can't get an input name."),l.push(e);let a=s.UTF8ToString(e);c.push(a),m.push(0===r?{name:a,isTensor:!1}:{name:a,isTensor:!0,type:el(r),shape:n})}for(let r=0;r<p;r++){let[n,a,i]=eG(o,r+e);0===n&&er("Can't get an output name."),f.push(n);let u=s.UTF8ToString(n);h.push(u),y.push(0===a?{name:u,isTensor:!1}:{name:u,isTensor:!0,type:el(a),shape:i});{if(d&&t?.preferredOutputLocation===void 0){w.push("gpu-buffer");continue}let e="string"==typeof t?.preferredOutputLocation?t.preferredOutputLocation:t?.preferredOutputLocation?.[u]??"cpu",r=s.webnnIsGraphOutput;if("cpu"===e&&r&&r(o,u)){w.push("ml-tensor-cpu-output");continue}if("cpu"!==e&&"cpu-pinned"!==e&&"gpu-buffer"!==e&&"ml-tensor"!==e)throw Error(`Not supported preferred output location: ${e}.`);if(d&&"gpu-buffer"!==e)throw Error(`Not supported preferred output location: ${e}. Only 'gpu-buffer' location is supported when enableGraphCapture is true.`);w.push(e)}}let g=null;return w.some(e=>"gpu-buffer"===e||"ml-tensor"===e||"ml-tensor-cpu-output"===e)&&(i=s._OrtCreateBinding(o),0===i&&er("Can't create IO binding."),g={handle:i,outputPreferredLocations:w,outputPreferredLocationsEncoded:w.map(e=>"ml-tensor-cpu-output"===e?"ml-tensor":e).map(e=>em(e))}),e_.set(o,[o,l,f,g,d,!1]),[o,c,h,m,y]}catch(e){throw l.forEach(e=>s._OrtFree(e)),f.forEach(e=>s._OrtFree(e)),0!==i&&0!==s._OrtReleaseBinding(i)&&er("Can't release IO binding."),0!==o&&0!==s._OrtReleaseSession(o)&&er("Can't release session."),e}finally{s._free(r),0!==a&&0!==s._OrtReleaseSessionOptions(a)&&er("Can't release session options."),u.forEach(e=>s._free(e)),s.unmountExternalData?.()}},ej=e=>{let t=Q(),r=e_.get(e);if(!r)throw Error(`cannot release session. invalid session id: ${e}`);let[n,s,o,a,i]=r;a&&(i&&0!==t._OrtClearBoundOutputs(a.handle)&&er("Can't clear bound outputs."),0!==t._OrtReleaseBinding(a.handle)&&er("Can't release IO binding.")),t.jsepOnReleaseSession?.(e),t.webnnOnReleaseSession?.(e),t.webgpuOnReleaseSession?.(e),s.forEach(e=>t._OrtFree(e)),o.forEach(e=>t._OrtFree(e)),0!==t._OrtReleaseSession(n)&&er("Can't release session."),e_.delete(e)},eF=async(e,t,r,n,s,o,a=!1)=>{let i,u;if(!e)return void t.push(0);let l=Q(),f=l.PTR_SIZE,p=e[0],d=e[1],c=e[3],h=c;if("string"===p&&("gpu-buffer"===c||"ml-tensor"===c))throw Error("String tensor is not supported on GPU.");if(a&&"gpu-buffer"!==c)throw Error(`External buffer must be provided for input/output index ${o} when enableGraphCapture is true.`);if("gpu-buffer"===c){let t=e[2].gpuBuffer;u=ef(eu(p),d);{let e=l.webgpuRegisterBuffer;if(!e)throw Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');i=e(t,n)}}else if("ml-tensor"===c){let t=e[2].mlTensor;u=ef(eu(p),d);let r=l.webnnRegisterMLTensor;if(!r)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');i=r(n,t,eu(p),d)}else{let t=e[2];if(Array.isArray(t)){u=f*t.length,i=l._malloc(u),r.push(i);for(let e=0;e<t.length;e++){if("string"!=typeof t[e])throw TypeError(`tensor data at index ${e} is not a string`);l.setValue(i+e*f,ee(t[e],r),"*")}}else{let e=l.webnnIsGraphInput,o=l.webnnIsGraphOutput;if("string"!==p&&e&&o){let a=l.UTF8ToString(s);if(e(n,a)||o(n,a)){let e=eu(p);u=ef(e,d),h="ml-tensor";let r=l.webnnCreateTemporaryTensor,s=l.webnnUploadTensor;if(!r||!s)throw Error('Tensor location "ml-tensor" is not supported without using WebNN.');let o=await r(n,e,d);s(o,new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),i=o}else u=t.byteLength,i=l._malloc(u),r.push(i),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),i)}else u=t.byteLength,i=l._malloc(u),r.push(i),l.HEAPU8.set(new Uint8Array(t.buffer,t.byteOffset,u),i)}}let m=l.stackSave(),y=l.stackAlloc(4*d.length);try{d.forEach((e,t)=>l.setValue(y+t*f,e,4===f?"i32":"i64"));let e=l._OrtCreateTensor(eu(p),i,u,y,d.length,em(h));0===e&&er(`Can't create tensor for input/output. session=${n}, index=${o}.`),t.push(e)}finally{l.stackRestore(m)}},eV=async(e,t,r,n,s,o)=>{let a=Q(),i=a.PTR_SIZE,u=e_.get(e);if(!u)throw Error(`cannot run inference. invalid session id: ${e}`);let l=u[0],f=u[1],p=u[2],d=u[3],c=u[4],h=u[5],m=t.length,y=n.length,w=0,g=[],b=[],v=[],T=[],E=a.stackSave(),I=a.stackAlloc(m*i),A=a.stackAlloc(m*i),C=a.stackAlloc(y*i),x=a.stackAlloc(y*i);try{let u;[w,g]=en(o),$("wasm prepareInputOutputTensor");for(let n=0;n<m;n++)await eF(r[n],b,T,e,f[t[n]],t[n],c);for(let t=0;t<y;t++)await eF(s[t],v,T,e,p[n[t]],m+n[t],c);R("wasm prepareInputOutputTensor");for(let e=0;e<m;e++)a.setValue(I+e*i,b[e],"*"),a.setValue(A+e*i,f[t[e]],"*");for(let e=0;e<y;e++)a.setValue(C+e*i,v[e],"*"),a.setValue(x+e*i,p[n[e]],"*");if(d&&!h){let{handle:r,outputPreferredLocations:o,outputPreferredLocationsEncoded:i}=d;if(f.length!==m)throw Error(`input count from feeds (${m}) is expected to be always equal to model's input count (${f.length}).`);$("wasm bindInputsOutputs");for(let n=0;n<m;n++){let s=t[n],o=await a._OrtBindInput(r,f[s],b[n]);0!==o&&er(`Can't bind input[${n}] for session=${e}.`)}for(let t=0;t<y;t++){let u=n[t];if(s[t]?.[3]){let n=a._OrtBindOutput(r,p[u],v[t],0);0!==n&&er(`Can't bind pre-allocated output[${t}] for session=${e}.`)}else{let n=a._OrtBindOutput(r,p[u],0,i[u]);0!==n&&er(`Can't bind output[${t}] to ${o[t]} for session=${e}.`)}}R("wasm bindInputsOutputs"),e_.set(e,[l,f,p,d,c,!0])}a.jsepOnRunStart?.(l),a.webnnOnRunStart?.(l),u=d?await a._OrtRunWithBinding(l,d.handle,y,C,w):await a._OrtRun(l,A,I,m,x,y,C,w),0!==u&&er("failed to call OrtRun().");let E=[],O=[];$("wasm ProcessOutputTensor");for(let t=0;t<y;t++){let r=Number(a.getValue(C+t*i,"*"));if(r===v[t]){E.push(s[t]);continue}let o=a.stackSave(),u=a.stackAlloc(4*i),l=!1,f,p=0;try{let s=a._OrtGetTensorData(r,u,u+i,u+2*i,u+3*i);0!==s&&er(`Can't access output tensor data on index ${t}.`);let o=4===i?"i32":"i64",c=Number(a.getValue(u,o));p=a.getValue(u+i,"*");let h=a.getValue(u+2*i,"*"),m=Number(a.getValue(u+3*i,o)),y=[];for(let e=0;e<m;e++)y.push(Number(a.getValue(h+e*i,o)));0!==a._OrtFree(h)&&er("Can't free memory for tensor dims.");let w=y.reduce((e,t)=>e*t,1);f=el(c);let g=d?.outputPreferredLocations[n[t]];if("string"===f){if("gpu-buffer"===g||"ml-tensor"===g)throw Error("String tensor is not supported on GPU.");let e=[];for(let t=0;t<w;t++){let r=a.getValue(p+t*i,"*"),n=a.getValue(p+(t+1)*i,"*"),s=t===w-1?void 0:n-r;e.push(a.UTF8ToString(r,s))}E.push([f,y,e,"cpu"])}else if("gpu-buffer"===g&&w>0){let t=a.webgpuGetBuffer;if(!t)throw Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let n=t(p),s=ef(c,w);if(void 0===s||!ec(f))throw Error(`Unsupported data type: ${f}`);l=!0;{a.webgpuRegisterBuffer(n,e,p);let t=a.webgpuCreateDownloader(n,s,e);E.push([f,y,{gpuBuffer:n,download:async()=>{let e=await t();return new(ep(f))(e)},dispose:()=>{0!==a._OrtReleaseTensor(r)&&er("Can't release tensor.")}},"gpu-buffer"])}}else if("ml-tensor"===g&&w>0){let t=a.webnnEnsureTensor,n=a.webnnIsGraphInputOutputTypeSupported;if(!t||!n)throw Error('preferredLocation "ml-tensor" is not supported without using WebNN.');let s=ef(c,w);if(void 0===s||!eh(f))throw Error(`Unsupported data type: ${f}`);if(!n(e,f,!1))throw Error(`preferredLocation "ml-tensor" for ${f} output is not supported by current WebNN Context.`);let o=await t(e,p,c,y,!1);l=!0,E.push([f,y,{mlTensor:o,download:a.webnnCreateMLTensorDownloader(p,f),dispose:()=>{a.webnnReleaseTensorId(p),a._OrtReleaseTensor(r)}},"ml-tensor"])}else if("ml-tensor-cpu-output"===g&&w>0){let e=a.webnnCreateMLTensorDownloader(p,f)(),t=E.length;l=!0,O.push((async()=>{let n=[t,await e];return a.webnnReleaseTensorId(p),a._OrtReleaseTensor(r),n})()),E.push([f,y,[],"cpu"])}else{let e=new(ep(f))(w);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(a.HEAPU8.subarray(p,p+e.byteLength)),E.push([f,y,e,"cpu"])}}finally{a.stackRestore(o),"string"===f&&p&&a._free(p),l||a._OrtReleaseTensor(r)}}for(let[t,r]of(d&&!c&&(0!==a._OrtClearBoundOutputs(d.handle)&&er("Can't clear bound outputs."),e_.set(e,[l,f,p,d,c,!1])),await Promise.all(O)))E[t][2]=r;return R("wasm ProcessOutputTensor"),E}finally{a.webnnOnRunEnd?.(l),a.stackRestore(E),r.forEach(e=>{e&&"gpu-buffer"===e[3]&&a.webgpuUnregisterBuffer(e[2].gpuBuffer)}),s.forEach(e=>{e&&"gpu-buffer"===e[3]&&a.webgpuUnregisterBuffer(e[2].gpuBuffer)}),b.forEach(e=>a._OrtReleaseTensor(e)),v.forEach(e=>a._OrtReleaseTensor(e)),T.forEach(e=>a._free(e)),0!==w&&a._OrtReleaseRunOptions(w),g.forEach(e=>a._free(e))}},ez=e=>{let t=Q(),r=e_.get(e);if(!r)throw Error("invalid session id");let n=r[0],s=t._OrtEndProfiling(n);0===s&&er("Can't get an profile file name."),t._OrtFree(s)},eH=e=>{let t=[];for(let r of e){let e=r[2];!Array.isArray(e)&&"buffer"in e&&t.push(e.buffer)}return t}}}),tJ=td({"web/lib/wasm/proxy-wrapper.ts"(){"use strict";tB(),tY(),tG(),t_(),eq=()=>!!l.wasm.proxy&&"undefined"!=typeof document,eX=!1,eY=!1,eJ=!1,e0=new Map,e1=(e,t)=>{let r=e0.get(e);r?r.push(t):e0.set(e,[t])},e2=()=>{if(eX||!eY||eJ||!eZ)throw Error("worker not ready")},e3=e=>{switch(e.data.type){case"init-wasm":eX=!1,e.data.err?(eJ=!0,eQ[1](e.data.err)):(eY=!0,eQ[0]()),eK&&(URL.revokeObjectURL(eK),eK=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let t=e0.get(e.data.type);e.data.err?t.shift()[1](e.data.err):t.shift()[0](e.data.out)}}},e4=async()=>{if(!eY){if(eX)throw Error("multiple calls to 'initWasm()' detected.");if(eJ)throw Error("previous call to 'initWasm()' failed.");if(eX=!0,eq())return new Promise((e,t)=>{eZ?.terminate(),z().then(([r,n])=>{try{(eZ=n).onerror=e=>t(e),eZ.onmessage=e3,eQ=[e,t];let s={type:"init-wasm",in:l};if(!s.in.wasm.wasmPaths&&r){let e=D();e&&(s.in.wasm.wasmPaths=e)}eZ.postMessage(s),eK=r}catch(e){t(e)}},t)});try{await K(l.wasm),await ek(l),eY=!0}catch(e){throw eJ=!0,e}finally{eX=!1}}},e6=async e=>{if(eq())return e2(),new Promise((t,r)=>{e1("init-ep",[t,r]);let n={type:"init-ep",in:{epName:e,env:l}};eZ.postMessage(n)});await eP(l,e)},e8=async e=>eq()?(e2(),new Promise((t,r)=>{e1("copy-from",[t,r]),eZ.postMessage({type:"copy-from",in:{buffer:e}},[e.buffer])})):eD(e),e5=async(e,t)=>{if(!eq())return eW(e,t);if(t?.preferredOutputLocation)throw Error('session option "preferredOutputLocation" is not supported for proxy.');return e2(),new Promise((r,n)=>{e1("create",[r,n]);let s={type:"create",in:{model:e,options:{...t}}},o=[];e instanceof Uint8Array&&o.push(e.buffer),eZ.postMessage(s,o)})},e9=async e=>{if(eq())return e2(),new Promise((t,r)=>{e1("release",[t,r]),eZ.postMessage({type:"release",in:e})});ej(e)},e7=async(e,t,r,n,s,o)=>{if(!eq())return eV(e,t,r,n,s,o);if(r.some(e=>"cpu"!==e[3]))throw Error("input tensor on GPU is not supported for proxy.");if(s.some(e=>e))throw Error("pre-allocated output tensor is not supported for proxy.");return e2(),new Promise((s,a)=>{e1("run",[s,a]),eZ.postMessage({type:"run",in:{sessionId:e,inputIndices:t,inputs:r,outputIndices:n,options:o}},eH(r))})},te=async e=>{if(eq())return e2(),new Promise((t,r)=>{e1("end-profiling",[t,r]),eZ.postMessage({type:"end-profiling",in:e})});ez(e)}}}),tK=td({"web/lib/wasm/session-handler-inference.ts"(){"use strict";tB(),tJ(),tF(),tS(),tV(),tt=(e,t)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw Error(`invalid data location: ${e.location} for ${t()}`)}},tr=e=>{switch(e[3]){case"cpu":return new C(e[0],e[2],e[1]);case"gpu-buffer":{let t=e[0];if(!ec(t))throw Error(`not supported data type: ${t} for deserializing GPU tensor`);let{gpuBuffer:r,download:n,dispose:s}=e[2];return C.fromGpuBuffer(r,{dataType:t,dims:e[1],download:n,dispose:s})}case"ml-tensor":{let t=e[0];if(!eh(t))throw Error(`not supported data type: ${t} for deserializing MLTensor tensor`);let{mlTensor:r,download:n,dispose:s}=e[2];return C.fromMLTensor(r,{dataType:t,dims:e[1],download:n,dispose:s})}default:throw Error(`invalid data location: ${e[3]}`)}},tn=class{async fetchModelAndCopyToWasmMemory(e){return e8(await ey(e))}async loadModel(e,t){let r;U(),r="string"==typeof e?B?await ey(e):await this.fetchModelAndCopyToWasmMemory(e):e,[this.sessionId,this.inputNames,this.outputNames,this.inputMetadata,this.outputMetadata]=await e5(r,t),L()}async dispose(){return e9(this.sessionId)}async run(e,t,r){U();let n=[],s=[];Object.entries(e).forEach(e=>{let t=e[0],r=e[1],o=this.inputNames.indexOf(t);if(-1===o)throw Error(`invalid input '${t}'`);n.push(r),s.push(o)});let o=[],a=[];Object.entries(t).forEach(e=>{let t=e[0],r=e[1],n=this.outputNames.indexOf(t);if(-1===n)throw Error(`invalid output '${t}'`);o.push(r),a.push(n)});let i=n.map((e,t)=>tt(e,()=>`input "${this.inputNames[s[t]]}"`)),u=o.map((e,t)=>e?tt(e,()=>`output "${this.outputNames[a[t]]}"`):null),l=await e7(this.sessionId,s,i,a,u,r),f={};for(let e=0;e<l.length;e++)f[this.outputNames[a[e]]]=o[e]??tr(l[e]);return L(),f}startProfiling(){}endProfiling(){te(this.sessionId)}}}}),tQ={};tc(tQ,{OnnxruntimeWebAssemblyBackend:()=>to,initializeFlags:()=>ts,wasmBackend:()=>ta});var t0=td({"web/lib/backend-wasm.ts"(){"use strict";tB(),tJ(),tK(),ts=()=>{("number"!=typeof l.wasm.initTimeout||l.wasm.initTimeout<0)&&(l.wasm.initTimeout=0);let e=l.wasm.simd;if("boolean"!=typeof e&&void 0!==e&&"fixed"!==e&&"relaxed"!==e&&(console.warn(`Property "env.wasm.simd" is set to unknown value "${e}". Reset it to \`false\` and ignore SIMD feature checking.`),l.wasm.simd=!1),"boolean"!=typeof l.wasm.proxy&&(l.wasm.proxy=!1),"boolean"!=typeof l.wasm.trace&&(l.wasm.trace=!1),"number"!=typeof l.wasm.numThreads||!Number.isInteger(l.wasm.numThreads)||l.wasm.numThreads<=0)if("undefined"==typeof self||self.crossOriginIsolated){let e="undefined"==typeof navigator?tp("node:os").cpus().length:navigator.hardwareConcurrency;l.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}else l.wasm.numThreads=1},ta=new(to=class{async init(e){ts(),await e4(),await e6(e)}async createInferenceSessionHandler(e,t){let r=new tn;return await r.loadModel(e,t),r}})}});tB(),tB(),tB();var t1=tN;{let e=(t0(),th(tQ)).wasmBackend;n("webgpu",e,5),n("webnn",e,5),n("cpu",e,10),n("wasm",e,10)}Object.defineProperty(l.versions,"web",{value:"1.23.2",enumerable:!0});export{N as InferenceSession,x as TRACE,$ as TRACE_EVENT_BEGIN,R as TRACE_EVENT_END,U as TRACE_FUNC_BEGIN,L as TRACE_FUNC_END,C as Tensor,t1 as default,l as env,n as registerBackend};