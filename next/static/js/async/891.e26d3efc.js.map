{"version":3,"file":"static/js/async/891.e26d3efc.js","sources":["../../../../../../packages/ui/src/workers/graphLayout.worker.ts"],"sourcesContent":["// Types needed for the worker\ninterface Node {\n  id: string;\n  width?: number;\n  height?: number;\n  position: { x: number; y: number };\n  [key: string]: any;\n}\n\ninterface Edge {\n  id: string;\n  source: string;\n  target: string;\n  [key: string]: any;\n}\n\ninterface LayoutMessage {\n  nodes: Node[];\n  edges: Edge[];\n  direction: 'TB' | 'LR';\n}\n\n// Node size constants\nconst NODE_WIDTH = 24;\nconst NODE_HEIGHT = 24;\nconst H_SPACING = 14; // horizontal gap between siblings (perpendicular axis)\nconst V_SPACING = 18; // vertical gap between levels (main axis)\n\n/**\n * OGS-style Tree Layout Algorithm: Main Line Straight with Branching Variations\n *\n * Key principle: The main line (first child at each node) stays on a straight line,\n * while variations (2nd, 3rd, etc. children) branch off perpendicular to the main line.\n *\n * For horizontal layout (LR):\n * - Main line goes left-to-right at y=0\n * - Variations branch downward (positive y)\n *\n * For vertical layout (TB):\n * - Main line goes top-to-bottom at x=0\n * - Variations branch rightward (positive x)\n *\n * Algorithm: Two-pass with proper subtree width calculation\n * 1. First pass (post-order): Calculate space needed by each subtree\n * 2. Second pass (pre-order): Position nodes, main line at top, variations below\n *\n * Key: Early branches stay close to main line, later branches go further out\n */\nfunction layoutOGS(nodes: Node[], edges: Edge[], direction: 'TB' | 'LR'): Node[] {\n  if (nodes.length === 0) return nodes;\n\n  // Build adjacency map from edges (parent -> children)\n  const childrenMap = new Map<string, string[]>();\n  const parentMap = new Map<string, string>();\n\n  for (const edge of edges) {\n    if (!childrenMap.has(edge.source)) {\n      childrenMap.set(edge.source, []);\n    }\n    childrenMap.get(edge.source)!.push(edge.target);\n    parentMap.set(edge.target, edge.source);\n  }\n\n  // Find root node (node with no parent)\n  const nodeIds = new Set(nodes.map(n => n.id));\n  let rootId: string | null = null;\n  for (const nodeId of nodeIds) {\n    if (!parentMap.has(nodeId)) {\n      rootId = nodeId;\n      break;\n    }\n  }\n\n  if (!rootId) {\n    rootId = nodes[0].id;\n  }\n\n  const positions = new Map<string, { x: number; y: number }>();\n  const isHorizontal = direction === 'LR';\n  const nodeSpacing = NODE_HEIGHT + H_SPACING;\n\n  // Track the next available offset at each depth level\n  // This ensures no two nodes at the same depth overlap\n  const nextOffsetAtDepth = new Map<number, number>();\n\n  /**\n   * Position nodes using a single pre-order traversal.\n   *\n   * Key insight: We track the \"next available offset\" at each depth.\n   * - Main line nodes continue at the same offset as parent\n   * - Variations take the next available offset at their depth\n   * - After placing a node, we update the next available offset for that depth\n   *\n   * @param nodeId - current node to position\n   * @param depth - depth along the main axis (move number)\n   * @param inheritedOffset - the offset inherited from parent (for main line continuity), or -1 if should use next available\n   */\n  function assignPositions(nodeId: string, depth: number, inheritedOffset: number): void {\n    const children = childrenMap.get(nodeId) || [];\n\n    // Get the next available offset at this depth\n    const nextAvailable = nextOffsetAtDepth.get(depth) ?? 0;\n\n    // Determine actual offset:\n    // - If inheritedOffset is -1, use next available (for variations)\n    // - Otherwise, use max of inherited and next available (for main line)\n    const actualOffset =\n      inheritedOffset < 0 ? nextAvailable : Math.max(inheritedOffset, nextAvailable);\n\n    // Position along main axis\n    const mainAxisPos = depth * (isHorizontal ? NODE_WIDTH + V_SPACING : NODE_HEIGHT + V_SPACING);\n\n    // Position this node\n    if (isHorizontal) {\n      positions.set(nodeId, { x: mainAxisPos, y: actualOffset });\n    } else {\n      positions.set(nodeId, { x: actualOffset, y: mainAxisPos });\n    }\n\n    // Update next available offset for this depth\n    nextOffsetAtDepth.set(depth, actualOffset + nodeSpacing);\n\n    if (children.length === 0) return;\n\n    // Main line child inherits the same offset (for straight continuation)\n    // Variations get placed at the next available offset at their depth\n    for (let i = 0; i < children.length; i++) {\n      if (i === 0) {\n        // Main line - inherit same offset\n        assignPositions(children[i], depth + 1, actualOffset);\n      } else {\n        // Variation - use -1 to signal \"use next available\"\n        assignPositions(children[i], depth + 1, -1);\n      }\n    }\n  }\n\n  // Execute the algorithm\n  assignPositions(rootId, 0, 0);\n\n  // Apply positions to nodes\n  return nodes.map(node => {\n    const pos = positions.get(node.id);\n    if (pos) {\n      return {\n        ...node,\n        position: pos,\n      };\n    }\n    return node;\n  });\n}\n\nself.onmessage = (event: MessageEvent<LayoutMessage>) => {\n  const { nodes, edges, direction } = event.data;\n\n  const start = performance.now();\n  const layoutedNodes = layoutOGS(nodes, edges, direction);\n  const duration = performance.now() - start;\n\n  self.postMessage({\n    nodes: layoutedNodes,\n    edges,\n    duration,\n  });\n};\n"],"names":["self","event","nodes","edges","direction","start","performance","layoutedNodes","layoutOGS","childrenMap","Map","parentMap","edge","nodeIds","Set","n","rootId","nodeId","positions","isHorizontal","nextOffsetAtDepth","assignPositions","depth","inheritedOffset","children","nextAvailable","actualOffset","Math","mainAxisPos","NODE_WIDTH","NODE_HEIGHT","i","node","pos","duration"],"mappings":"AAyJAA,KAAK,SAAS,CAAG,AAACC,IAChB,GAAM,CAAEC,MAAAA,CAAK,CAAEC,MAAAA,CAAK,CAAEC,UAAAA,CAAS,CAAE,CAAGH,EAAM,IAAI,CAExCI,EAAQC,YAAY,GAAG,GACvBC,EAAgBC,AA7GxB,SAAmBN,CAAa,CAAEC,CAAa,CAAEC,CAAsB,EACrE,GAAIF,AAAiB,IAAjBA,EAAM,MAAM,CAAQ,OAAOA,EAG/B,IAAMO,EAAc,IAAIC,IAClBC,EAAY,IAAID,IAEtB,IAAK,IAAME,KAAQT,EACb,AAACM,EAAY,GAAG,CAACG,EAAK,MAAM,GAC9BH,EAAY,GAAG,CAACG,EAAK,MAAM,CAAE,EAAE,EAEjCH,EAAY,GAAG,CAACG,EAAK,MAAM,EAAG,IAAI,CAACA,EAAK,MAAM,EAC9CD,EAAU,GAAG,CAACC,EAAK,MAAM,CAAEA,EAAK,MAAM,EAIxC,IAAMC,EAAU,IAAIC,IAAIZ,EAAM,GAAG,CAACa,AAAAA,GAAKA,EAAE,EAAE,GACvCC,EAAwB,KAC5B,IAAK,IAAMC,KAAUJ,EACnB,GAAI,CAACF,EAAU,GAAG,CAACM,GAAS,CAC1BD,EAASC,EACT,KACF,CAGE,AAACD,GACHA,CAAAA,EAASd,CAAK,CAAC,EAAE,CAAC,EAAE,AAAD,EAGrB,IAAMgB,EAAY,IAAIR,IAChBS,EAAef,AAAc,OAAdA,EAKfgB,EAAoB,IAAIV,IA0D9B,OAHAW,AAzCA,SAASA,EAAgBJ,CAAc,CAAEK,CAAa,CAAEC,CAAuB,EAC7E,IAAMC,EAAWf,EAAY,GAAG,CAACQ,IAAW,EAAE,CAGxCQ,EAAgBL,EAAkB,GAAG,CAACE,IAAU,EAKhDI,EACJH,EAAkB,EAAIE,EAAgBE,KAAK,GAAG,CAACJ,EAAiBE,GAG5DG,EAAcN,AAAwBO,GAAxBP,EAYpB,GATIH,EACFD,EAAU,GAAG,CAACD,EAAQ,CAAE,EAAGW,EAAa,EAAGF,CAAa,GAExDR,EAAU,GAAG,CAACD,EAAQ,CAAE,EAAGS,EAAc,EAAGE,CAAY,GAI1DR,EAAkB,GAAG,CAACE,EAAOI,EAzCXI,IA2CdN,AAAoB,IAApBA,EAAS,MAAM,CAInB,IAAK,IAAIO,EAAI,EAAGA,EAAIP,EAAS,MAAM,CAAEO,IAC/BA,AAAM,IAANA,EAEFV,EAAgBG,CAAQ,CAACO,EAAE,CAAET,EAAQ,EAAGI,GAGxCL,EAAgBG,CAAQ,CAACO,EAAE,CAAET,EAAQ,EAAG,GAG9C,EAGgBN,EAAQ,EAAG,GAGpBd,EAAM,GAAG,CAAC8B,AAAAA,IACf,IAAMC,EAAMf,EAAU,GAAG,CAACc,EAAK,EAAE,SACjC,AAAIC,EACK,CACL,GAAGD,CAAI,CACP,SAAUC,CACZ,EAEKD,CACT,EACF,EAMkC9B,EAAOC,EAAOC,GACxC8B,EAAW5B,YAAY,GAAG,GAAKD,EAErCL,KAAK,WAAW,CAAC,CACf,MAAOO,EACPJ,MAAAA,EACA+B,SAAAA,CACF,EACF"}